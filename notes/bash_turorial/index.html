
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://iswade.github.io/notes/bash_turorial/">
      
      <link rel="icon" href="../../themes/me.svg">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>bash教程 - iswade's blog</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.975780f9.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.2505c338.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../themes/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="preference" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bash" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="iswade&#39;s blog" class="md-header__button md-logo" aria-label="iswade's blog" data-md-component="logo">
      
  <img src="../../themes/me.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            iswade's blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              bash教程
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="iswade&#39;s blog" class="md-nav__button md-logo" aria-label="iswade's blog" data-md-component="logo">
      
  <img src="../../themes/me.svg" alt="logo">

    </a>
    iswade's blog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        主页
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          数据库
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数据库" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          数据库
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../adb_nodes/00_index/" class="md-nav__link">
        高级数据库笔记
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/buffer/buffer_details/" class="md-nav__link">
        PostgreSQL缓存
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/crdb/crdb_paper_cn/" class="md-nav__link">
        CockroachDB翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/crdb/crdb_paper/" class="md-nav__link">
        CockroachDB论文
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/taurus_paper_cn/" class="md-nav__link">
        TaurusDB翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/taurus_paper/" class="md-nav__link">
        TaurusDB论文
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/pebble/" class="md-nav__link">
        Pebble KV存储引擎
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/faunadb_transaction/" class="md-nav__link">
        FaunaDB分布式事务协议
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/Aurora_design_cloud_native_database/" class="md-nav__link">
        Aurora云原生关系数据库
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/btree_vs_lsmtree/" class="md-nav__link">
        现代存储系统背后的算法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../db_nodes/00_database_systems_2018/" class="md-nav__link">
        数据库笔记
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/F1_query/" class="md-nav__link">
        F1 Query
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          分布式系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="分布式系统" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          分布式系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/distsys/" class="md-nav__link">
        分布式系统大纲
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/partition/" class="md-nav__link">
        数据分区
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/strong_consistency_models/" class="md-nav__link">
        强一致性模型
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/zookeeper/" class="md-nav__link">
        Zookeeper论文翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/paxos_made_live/" class="md-nav__link">
        Paxos Made Live翻译
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          编程语言
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="编程语言" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          编程语言
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/go_concurrency/" class="md-nav__link">
        Go并发编程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/go_interface/" class="md-nav__link">
        如何使用Go接口
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          软件工程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="软件工程" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          软件工程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../pragmatic_programmer/" class="md-nav__link">
        程序员修炼之道
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          bash教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        bash教程
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    Shell 的含义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell_1" class="md-nav__link">
    Shell 的种类
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    命令行环境
  </a>
  
    <nav class="md-nav" aria-label="命令行环境">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    终端模拟器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    命令行提示符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    进入和退出方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell-bash" class="md-nav__link">
    Shell 和 Bash 的历史
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/linux_sysadmin/" class="md-nav__link">
        linux系统管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../git/" class="md-nav__link">
        git入门教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../translate/to_be_manager/" class="md-nav__link">
        How to be a manager
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    Shell 的含义
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell_1" class="md-nav__link">
    Shell 的种类
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    命令行环境
  </a>
  
    <nav class="md-nav" aria-label="命令行环境">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    终端模拟器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    命令行提示符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    进入和退出方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell-bash" class="md-nav__link">
    Shell 和 Bash 的历史
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="bash">Bash 简介</h1>
<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。</p>
<h2 id="shell">Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（commandline，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="shell_1">Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell（sh）</li>
<li>Bourne Again shell（bash）</li>
<li>C Shell（csh）</li>
<li>TENEX C Shell（tcsh）</li>
<li>Korn shell（ksh）</li>
<li>Z Shell（zsh）</li>
<li>Friendly Interactive Shell（fish）</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/bash
</code></pre></div>

<p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div class="highlight"><pre><span></span><code>$ cat /etc/shells
</code></pre></div>

<p>上面两个命令中，<code>$</code>是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="_1">命令行环境</h2>
<h3 id="_2">终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统（比如专用于服务器的系统），启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”（terminal emulator）就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版（准确地说是不同的桌面环境）带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="_3">命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号<code>$</code>结尾，用户可以在这个符号后面输入各种命令。</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>user@hostname<span class="o">]</span> $
</code></pre></div>

<p>上面例子中，完整的提示符是<code>[user@hostname] $</code>，其中前缀是用户名（<code>user</code>）加上<code>@</code>，再加主机名（<code>hostname</code>）。比如，用户名是<code>bill</code>，主机名是<code>home-machine</code>，前缀就是<code>bill@home-machine</code>。</p>
<p>注意，根用户（root）的提示符，不以美元符号（<code>$</code>）结尾，而以井号（<code>#</code>）结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用<code>$</code>表示。</p>
<h3 id="_4">进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果你的 Shell 不是 Bash，可以输入<code>bash</code>命令启动 Bash。</p>
<div class="highlight"><pre><span></span><code>$ bash
</code></pre></div>

<p>退出 Bash 环境，可以使用<code>exit</code>命令，也可以同时按下<code>Ctrl + d</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">exit</span>
</code></pre></div>

<p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入<code>pwd</code>命令。按下回车键，就会显示当前所在的目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">pwd</span>
/home/me
</code></pre></div>

<p>如果不小心输入了<code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div class="highlight"><pre><span></span><code>$ pwe
bash: pwe：未找到命令
</code></pre></div>

<h2 id="shell-bash">Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是<code>sh</code>，方便用户使用 Unix。</p>
<p>1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是<code>csh</code>。它是第一个真正替代<code>sh</code>的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是<code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983年，David Korn 开发了Korn shell，程序名是<code>ksh</code>。</p>
<p>1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为<code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989年，Bash 发布1.0版。</p>
<p>1996年，Bash 发布2.0版。</p>
<p>2004年，Bash 发布3.0版。</p>
<p>2009年，Bash 发布4.0版。</p>
<p>2019年，Bash 发布5.0版。</p>
<p>用户可以通过<code>bash</code>命令的<code>--version</code>参数或者环境变量<code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div class="highlight"><pre><span></span><code>$ bash --version
GNU bash，版本 <span class="m">5</span>.0.3<span class="o">(</span><span class="m">1</span><span class="o">)</span>-release <span class="o">(</span>x86_64-pc-linux-gnu<span class="o">)</span>

<span class="c1"># 或者</span>
$ <span class="nb">echo</span> <span class="nv">$BASH_VERSION</span>
<span class="m">5</span>.0.3<span class="o">(</span><span class="m">1</span><span class="o">)</span>-release
</code></pre></div>

<h1 id="bash_1">Bash 的基本语法</h1>
<p>本章介绍 Bash 的最基本语法。</p>
<h2 id="echo">echo 命令</h2>
<p>由于后面的例子会大量用到<code>echo</code>命令，这里先介绍这个命令。</p>
<p><code>echo</code>命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> hello world
hello world
</code></pre></div>

<p>上面例子中，<code>echo</code>的参数是<code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;&lt;HTML&gt;</span>
<span class="s2">    &lt;HEAD&gt;</span>
<span class="s2">          &lt;TITLE&gt;Page Title&lt;/TITLE&gt;</span>
<span class="s2">    &lt;/HEAD&gt;</span>
<span class="s2">    &lt;BODY&gt;</span>
<span class="s2">          Page body.</span>
<span class="s2">    &lt;/BODY&gt;</span>
<span class="s2">&lt;/HTML&gt;&quot;</span>
</code></pre></div>

<p>上面例子中，<code>echo</code>可以原样输出多行文本。</p>
<h3 id="-n"><code>-n</code>参数</h3>
<p>默认情况下，<code>echo</code>输出的文本末尾会有一个回车符。<code>-n</code>参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> -n hello world
hello world$
</code></pre></div>

<p>上面例子中，<code>world</code>后面直接就是下一行的提示符<code>$</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> a<span class="p">;</span><span class="nb">echo</span> b
a
b

$ <span class="nb">echo</span> -n a<span class="p">;</span><span class="nb">echo</span> b
ab
</code></pre></div>

<p>上面例子中，<code>-n</code>参数可以让两个<code>echo</code>命令的输出连在一起，出现在同一行。</p>
<h3 id="-e"><code>-e</code>参数</h3>
<p><code>-e</code>参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符<code>\n</code>）。如果不使用<code>-e</code>参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code>不解释它们，原样输出。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;Hello\nWorld&quot;</span>
Hello<span class="se">\n</span>World

<span class="c1"># 双引号的情况</span>
$ <span class="nb">echo</span> -e <span class="s2">&quot;Hello\nWorld&quot;</span>
Hello
World

<span class="c1"># 单引号的情况</span>
$ <span class="nb">echo</span> -e <span class="s1">&#39;Hello\nWorld&#39;</span>
Hello
World
</code></pre></div>

<p>上面代码中，<code>-e</code>参数使得<code>\n</code>解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="_5">命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">command</span> <span class="o">[</span> arg1 ... <span class="o">[</span> argN <span class="o">]]</span>
</code></pre></div>

<p>上面代码中，<code>command</code>是具体的命令或者一个可执行文件，<code>arg1 ... argN</code>是传递给命令的参数，它们是可选的。</p>
<div class="highlight"><pre><span></span><code>$ ls -l
</code></pre></div>

<p>上面这个命令中，<code>ls</code>是命令，<code>-l</code>是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的<code>-l</code>。同一个配置项往往有长和短两种形式，比如<code>-l</code>是短形式，<code>--list</code>是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 短形式</span>
$ ls -r

<span class="c1"># 长形式</span>
$ ls --reverse
</code></pre></div>

<p>上面命令中，<code>-r</code>是短形式，<code>--reverse</code>是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> foo bar

<span class="c1"># 等同于</span>
$ <span class="nb">echo</span> foo <span class="se">\</span>
bar
</code></pre></div>

<h2 id="_6">空格</h2>
<p>Bash 使用空格（或 Tab 键）区分不同的参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">command</span> foo bar
</code></pre></div>

<p>上面命令中，<code>foo</code>和<code>bar</code>之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> this is a     <span class="nb">test</span>
this is a <span class="nb">test</span>
</code></pre></div>

<p>上面命令中，<code>a</code>和<code>test</code>之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="_7">分号</h2>
<p>分号（<code>;</code>）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div class="highlight"><pre><span></span><code>$ clear<span class="p">;</span> ls
</code></pre></div>

<p>上面例子中，Bash 先执行<code>clear</code>命令，执行完成后，再执行<code>ls</code>命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="_8">命令的组合符<code>&amp;&amp;</code>和<code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符<code>&amp;&amp;</code>和<code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div class="highlight"><pre><span></span><code>Command1 <span class="o">&amp;&amp;</span> Command2
</code></pre></div>

<p>上面命令的意思是，如果<code>Command1</code>命令运行成功，则继续运行<code>Command2</code>命令。</p>
<div class="highlight"><pre><span></span><code>Command1 <span class="o">||</span> Command2
</code></pre></div>

<p>上面命令的意思是，如果<code>Command1</code>命令运行失败，则继续运行<code>Command2</code>命令。</p>
<p>下面是一些例子。</p>
<div class="highlight"><pre><span></span><code>$ cat filelist.txt <span class="p">;</span> ls -l filelist.txt
</code></pre></div>

<p>上面例子中，只要<code>cat</code>命令执行结束，不管成功或失败，都会继续执行<code>ls</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ cat filelist.txt <span class="o">&amp;&amp;</span> ls -l filelist.txt
</code></pre></div>

<p>上面例子中，只有<code>cat</code>命令执行成功，才会继续执行<code>ls</code>命令。如果<code>cat</code>执行失败（比如不存在文件<code>flielist.txt</code>），那么<code>ls</code>命令就不会执行。</p>
<div class="highlight"><pre><span></span><code>$ mkdir foo <span class="o">||</span> mkdir bar
</code></pre></div>

<p>上面例子中，只有<code>mkdir foo</code>命令执行失败（比如<code>foo</code>目录已经存在），才会继续执行<code>mkdir bar</code>命令。如果<code>mkdir foo</code>命令执行成功，就不会创建<code>bar</code>目录了。</p>
<h2 id="type">type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？</p>
<p><code>type</code>命令用来判断命令的来源。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">type</span> <span class="nb">echo</span>
<span class="nb">echo</span> is a shell <span class="nb">builtin</span>
$ <span class="nb">type</span> ls
ls is hashed <span class="o">(</span>/bin/ls<span class="o">)</span>
</code></pre></div>

<p>上面代码中，<code>type</code>命令告诉我们，<code>echo</code>是内部命令，<code>ls</code>是外部程序（<code>/bin/ls</code>）。</p>
<p><code>type</code>命令本身也是内置命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">type</span> <span class="nb">type</span>
<span class="nb">type</span> is a shell <span class="nb">builtin</span>
</code></pre></div>

<p>如果要查看一个命令的所有定义，可以使用<code>type</code>命令的<code>-a</code>参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">type</span> -a <span class="nb">echo</span>
<span class="nb">echo</span> is shell <span class="nb">builtin</span>
<span class="nb">echo</span> is /usr/bin/echo
<span class="nb">echo</span> is /bin/echo
</code></pre></div>

<p>上面代码表示，<code>echo</code>命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code>命令的<code>-t</code>参数，可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">type</span> -t bash
file
$ <span class="nb">type</span> -t <span class="k">if</span>
keyword
</code></pre></div>

<p>上面例子中，<code>bash</code>是文件，<code>if</code>是关键词。</p>
<h2 id="_9">快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见《行操作》一章。</p>
<ul>
<li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>：中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>：向上滚动。</li>
<li><code>Shift + PageDown</code>：向下滚动。</li>
<li><code>Ctrl + U</code>：从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>：从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>：关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>：浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入<code>pw</code>，然后按一下 Tab 键，Bash 会自动补上<code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让你选择。</p>
<h1 id="bash_2">Bash 的模式扩展</h1>
<h2 id="_10">简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code>这个词，来自于早期的 Unix 系统有一个<code>/etc/glob</code>文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">set</span> -o noglob
<span class="c1"># 或者</span>
$ <span class="nb">set</span> -f
</code></pre></div>

<p>下面的命令可以重新打开扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">set</span> +o noglob
<span class="c1"># 或者</span>
$ <span class="nb">set</span> +f
</code></pre></div>

<h2 id="_11">波浪线扩展</h2>
<p>波浪线<code>~</code>会自动扩展成当前用户的主目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> ~
/home/me
</code></pre></div>

<p><code>~/dir</code>表示扩展成主目录的某个子目录，<code>dir</code>是主目录里面的一个子目录名。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 进入 /home/me/foo 目录</span>
$ <span class="nb">cd</span> ~/foo
</code></pre></div>

<p><code>~user</code>表示扩展成用户<code>user</code>的主目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> ~foo
/home/foo

$ <span class="nb">echo</span> ~root
/root
</code></pre></div>

<p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果<code>~user</code>的<code>user</code>是不存在的用户名，则波浪号扩展不起作用。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> ~nonExistedUser
~nonExistedUser
</code></pre></div>

<p><code>~+</code>会扩展成当前所在的目录，等同于<code>pwd</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">cd</span> ~/foo
$ <span class="nb">echo</span> ~+
/home/me/foo
</code></pre></div>

<h2 id="_12"><code>?</code> 字符扩展</h2>
<p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code>匹配所有<code>Data</code>后面跟着三个字符的文件名。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在文件 a.txt 和 b.txt</span>
$ ls ?.txt
a.txt b.txt
</code></pre></div>

<p>上面命令中，<code>?</code>表示单个字符，所以会同时匹配<code>a.txt</code>和<code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个<code>?</code>连用。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ ls ??.txt
ab.txt
</code></pre></div>

<p>上面命令中，<code>??</code>匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 当前目录有 a.txt 文件</span>
$ <span class="nb">echo</span> ?.txt
a.txt

<span class="c1"># 当前目录为空目录</span>
$ <span class="nb">echo</span> ?.txt
?.txt
</code></pre></div>

<p>上面例子中，如果<code>?.txt</code>可以扩展成文件名，<code>echo</code>命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code>就会原样输出<code>?.txt</code>。</p>
<h2 id="_13"><code>*</code> 字符扩展</h2>
<p><code>*</code>字符代表文件路径里面的任意数量的字符，包括零个字符。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ ls *.txt
a.txt b.txt ab.txt

<span class="c1"># 输出所有文件</span>
$ ls *
</code></pre></div>

<p>下面是<code>*</code>匹配空字符的例子。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ ls a*.txt
a.txt ab.txt

$ ls *b*
b.txt ab.txt
</code></pre></div>

<p>注意，<code>*</code>不会匹配隐藏文件（以<code>.</code>开头的文件）。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 显示所有隐藏文件</span>
$ <span class="nb">echo</span> .*

<span class="c1"># 与方括号扩展结合使用，</span>
<span class="c1"># 只显示正常的隐藏文件，不显示 . 和 .. 这两个特殊文件</span>
$ <span class="nb">echo</span> .<span class="o">[</span>!.<span class="o">]</span>*
</code></pre></div>

<p><code>*</code>字符扩展也属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 当前目录不存在 c 开头的文件</span>
$ <span class="nb">echo</span> c*.txt
c*.txt
</code></pre></div>

<p>上面例子中，当前目录里面没有<code>c</code>开头的文件，导致<code>c*.txt</code>会原样输出。</p>
<p><code>*</code>只匹配当前目录，不会匹配子目录。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 子目录有一个 a.txt</span>
<span class="c1"># 无效的写法</span>
$ ls *.txt

<span class="c1"># 有效的写法</span>
$ ls */*.txt
</code></pre></div>

<p>上面的例子，文本文件在子目录，<code>*.txt</code>不会产生匹配，必须写成<code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数<code>globstar</code>，当该参数打开时，允许<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面<code>shopt</code>命令的介绍。</p>
<h2 id="_14">方括号扩展</h2>
<p>方括号扩展的形式是<code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code>可以匹配五个元音字母中的任意一个。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在文件 a.txt 和 b.txt</span>
$ ls <span class="o">[</span>ab<span class="o">]</span>.txt
a.txt b.txt

<span class="c1"># 只存在文件 a.txt</span>
$ ls <span class="o">[</span>ab<span class="o">]</span>.txt
a.txt
</code></pre></div>

<p>上面例子中，<code>[ab]</code>可以匹配<code>a</code>或<code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 不存在文件 a.txt 和 b.txt</span>
$ ls <span class="o">[</span>ab<span class="o">]</span>.txt
ls: 无法访问<span class="s1">&#39;[ab].txt&#39;</span>: 没有那个文件或目录
</code></pre></div>

<p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code>就原样输出了，导致<code>ls</code>命名报错。</p>
<p>方括号扩展还有两种变体：<code>[^...]</code>和<code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code>或<code>[!abc]</code>表示匹配除了<code>a</code>、<code>b</code>、<code>c</code>以外的字符。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在 aaa、bbb、aba 三个文件</span>
$ ls ?<span class="o">[</span>!a<span class="o">]</span>?
aba bbb
</code></pre></div>

<p>上面命令中，<code>[!a]</code>表示文件名第二个字符不是<code>a</code>的文件名，所以返回了<code>aba</code>和<code>bbb</code>两个文件。</p>
<p>注意，如果需要匹配<code>[</code>字符，可以放在方括号内，比如<code>[[aeiou]</code>。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如<code>[-aeiou]</code>或<code>[aeiou-]</code>。</p>
<h2 id="start-end">[start-end] 扩展</h2>
<p>方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code>等同于<code>[abc]</code>，<code>[0-9]</code>匹配<code>[0123456789]</code>。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 存在文件 a.txt、b.txt 和 c.txt</span>
$ ls <span class="o">[</span>a-c<span class="o">]</span>.txt
a.txt
b.txt
c.txt

<span class="c1"># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ ls report<span class="o">[</span><span class="m">0</span>-9<span class="o">]</span>.txt
report1.txt
report2.txt
report3.txt
...
</code></pre></div>

<p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>：所有小写字母。</li>
<li><code>[a-zA-Z]</code>：所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>：所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>：所有以<code>a</code>、<code>b</code>、<code>c</code>字符之一开头的文件名。</li>
<li><code>program.[co]</code>：文件<code>program.c</code>与文件<code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>：所有以<code>BACKUP.</code>开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code>表示匹配非英文字母的字符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> report<span class="o">[</span>!1–3<span class="o">]</span>.txt
report4.txt report5.txt
</code></pre></div>

<p>上面代码中，<code>[!1-3]</code>表示排除1、2和3。</p>
<h2 id="_15">大括号扩展</h2>
<p>大括号扩展<code>{...}</code>表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code>扩展成<code>1 2 3</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span><span class="m">1</span>,2,3<span class="o">}</span>
<span class="m">1</span> <span class="m">2</span> <span class="m">3</span>

$ <span class="nb">echo</span> d<span class="o">{</span>a,e,i,u,o<span class="o">}</span>g
dag deg dig dug dog

$ <span class="nb">echo</span> Front-<span class="o">{</span>A,B,C<span class="o">}</span>-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre></div>

<p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div class="highlight"><pre><span></span><code>$ ls <span class="o">{</span>a,b,c<span class="o">}</span>.txt
ls: 无法访问<span class="s1">&#39;a.txt&#39;</span>: 没有那个文件或目录
ls: 无法访问<span class="s1">&#39;b.txt&#39;</span>: 没有那个文件或目录
ls: 无法访问<span class="s1">&#39;c.txt&#39;</span>: 没有那个文件或目录
</code></pre></div>

<p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code>依然扩展成三个文件名，导致<code>ls</code>命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span><span class="m">1</span> , <span class="m">2</span><span class="o">}</span>
<span class="o">{</span><span class="m">1</span> , <span class="m">2</span><span class="o">}</span>
</code></pre></div>

<p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div class="highlight"><pre><span></span><code>$ cp a.log<span class="o">{</span>,.bak<span class="o">}</span>

<span class="c1"># 等同于</span>
<span class="c1"># cp a.log a.log.bak</span>
</code></pre></div>

<p>大括号可以嵌套。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>j<span class="o">{</span>p,pe<span class="o">}</span>g,png<span class="o">}</span>
jpg jpeg png

$ <span class="nb">echo</span> a<span class="o">{</span>A<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>,B<span class="o">{</span><span class="m">3</span>,4<span class="o">}}</span>b
aA1b aA2b aB3b aB4b
</code></pre></div>

<p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>cat,d*<span class="o">}</span>
cat dawg dg dig dog doug dug
</code></pre></div>

<p>上面例子中，会先进行大括号扩展，然后进行<code>*</code>扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>cat,dog<span class="o">}</span>
cat dog
</code></pre></div>

<p>由于大括号扩展<code>{...}</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 不存在 a.txt 和 b.txt</span>
$ <span class="nb">echo</span> <span class="o">[</span>ab<span class="o">]</span>.txt
<span class="o">[</span>ab<span class="o">]</span>.txt

$ <span class="nb">echo</span> <span class="o">{</span>a,b<span class="o">}</span>.txt
a.txt b.txt
</code></pre></div>

<p>上面例子中，如果不存在<code>a.txt</code>和<code>b.txt</code>，那么<code>[ab].txt</code>就会变成一个普通的文件名，而<code>{a,b}.txt</code>可以照样扩展。</p>
<h2 id="startend">{start..end} 扩展</h2>
<p>大括号扩展有一个简写形式<code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code>可以扩展成26个小写英文字母。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>a..c<span class="o">}</span>
a b c

$ <span class="nb">echo</span> d<span class="o">{</span>a..d<span class="o">}</span>g
dag dbg dcg ddg

$ <span class="nb">echo</span> <span class="o">{</span><span class="m">1</span>..4<span class="o">}</span>
<span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span>

$ <span class="nb">echo</span> Number_<span class="o">{</span><span class="m">1</span>..5<span class="o">}</span>
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre></div>

<p>这种简写形式支持逆序。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>c..a<span class="o">}</span>
c b a

$ <span class="nb">echo</span> <span class="o">{</span><span class="m">5</span>..1<span class="o">}</span>
<span class="m">5</span> <span class="m">4</span> <span class="m">3</span> <span class="m">2</span> <span class="m">1</span>
</code></pre></div>

<p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>a1..3c<span class="o">}</span>
<span class="o">{</span>a1..3c<span class="o">}</span>
</code></pre></div>

<p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> .<span class="o">{</span>mp<span class="o">{</span><span class="m">3</span>..4<span class="o">}</span>,m4<span class="o">{</span>a,b,p,v<span class="o">}}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre></div>

<p>大括号扩展的常见用途为新建一系列目录。</p>
<div class="highlight"><pre><span></span><code>$ mkdir <span class="o">{</span><span class="m">2007</span>..2009<span class="o">}</span>-<span class="o">{</span><span class="m">01</span>..12<span class="o">}</span>
</code></pre></div>

<p>上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于<code>for</code>循环。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> i in <span class="o">{</span><span class="m">1</span>..4<span class="o">}</span>
<span class="k">do</span>
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子会循环4次。</p>
<p>如果整数前面有前导<code>0</code>，扩展输出的每一项都有前导<code>0</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span><span class="m">01</span>..5<span class="o">}</span>
<span class="m">01</span> <span class="m">02</span> <span class="m">03</span> <span class="m">04</span> <span class="m">05</span>

$ <span class="nb">echo</span> <span class="o">{</span><span class="m">001</span>..5<span class="o">}</span>
<span class="m">001</span> <span class="m">002</span> <span class="m">003</span> <span class="m">004</span> <span class="m">005</span>
</code></pre></div>

<p>这种简写形式还可以使用第二个双点号（<code>start..end..step</code>），用来指定扩展的步长。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span><span class="m">0</span>..8..2<span class="o">}</span>
<span class="m">0</span> <span class="m">2</span> <span class="m">4</span> <span class="m">6</span> <span class="m">8</span>
</code></pre></div>

<p>上面代码将<code>0</code>扩展到<code>8</code>，每次递增的长度为<code>2</code>，所以一共输出5个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">{</span>a..c<span class="o">}{</span><span class="m">1</span>..3<span class="o">}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre></div>

<h2 id="_16">变量扩展</h2>
<p>Bash 将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/bash
</code></pre></div>

<p>变量名除了放在美元符号后面，也可以放在<code>${}</code>里面。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">SHELL</span><span class="si">}</span>
/bin/bash
</code></pre></div>

<p><code>${!string*}</code>或<code>${!string@}</code>返回所有匹配给定字符串<code>string</code>的变量名。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="si">${</span><span class="p">!S*</span><span class="si">}</span>
SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK
</code></pre></div>

<p>上面例子中，<code>${!S*}</code>扩展成所有以<code>S</code>开头的变量名。</p>
<h2 id="_17">子命令扩展</h2>
<p><code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$(</span>date<span class="k">)</span>
Tue Jan <span class="m">28</span> <span class="m">00</span>:01:13 CST <span class="m">2020</span>
</code></pre></div>

<p>上面例子中，<code>$(date)</code>返回<code>date</code>命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="sb">`</span>date<span class="sb">`</span>
Tue Jan <span class="m">28</span> <span class="m">00</span>:01:13 CST <span class="m">2020</span>
</code></pre></div>

<p><code>$(...)</code>可以嵌套，比如<code>$(ls $(pwd))</code>。</p>
<h2 id="_18">算术扩展</h2>
<p><code>$((...))</code>可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">2</span> <span class="o">+</span> <span class="m">2</span><span class="k">))</span>
<span class="m">4</span>
</code></pre></div>

<h2 id="_19">字符类</h2>
<p><code>[[:class:]]</code>表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>：匹配任意英文字母</li>
<li><code>[[:blank:]]</code>：空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li>
<li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li>
<li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）。</li>
</ul>
<p>请看下面的例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">[[</span>:upper:<span class="o">]]</span>*
</code></pre></div>

<p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号<code>!</code>，表示否定。比如，<code>[![:digit:]]</code>匹配所有非数字。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="o">[</span>!<span class="o">[</span>:digit:<span class="o">]]</span>*
</code></pre></div>

<p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 不存在以大写字母开头的文件</span>
$ <span class="nb">echo</span> <span class="o">[[</span>:upper:<span class="o">]]</span>*
<span class="o">[[</span>:upper:<span class="o">]]</span>*
</code></pre></div>

<p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="_20">使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p><strong>（1）通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div class="highlight"><pre><span></span><code>$ ls a*.txt
ab.txt
</code></pre></div>

<p>上面命令的执行过程是，Bash 先将<code>a*.txt</code>扩展成<code>ab.txt</code>，然后再执行<code>ls ab.txt</code>。</p>
<p><strong>（2）文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 不存在 r 开头的文件名</span>
$ <span class="nb">echo</span> r*
r*
</code></pre></div>

<p>上面代码中，由于不存在<code>r</code>开头的文件名，<code>r*</code>会原样输出。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre><span></span><code>$ ls *.csv
ls: *.csv: No such file or directory
</code></pre></div>

<p>另外，前面已经说过，大括号扩展<code>{...}</code>不是文件名扩展。</p>
<p><strong>（3）只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符（<code>/</code>）。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div class="highlight"><pre><span></span><code>$ ls */*.txt
</code></pre></div>

<p>Bash 4.0 新增了一个<code>globstar</code>参数，允许<code>**</code>匹配零个或多个子目录，详见后面<code>shopt</code>命令的介绍。</p>
<p><strong>（4）文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div class="highlight"><pre><span></span><code>$ touch <span class="s1">&#39;fo*&#39;</span>
$ ls
fo*
</code></pre></div>

<p>上面代码创建了一个<code>fo*</code>文件，这时<code>*</code>就是文件名的一部分。</p>
<h2 id="_21">量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> extglob
extglob         on
</code></pre></div>

<p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>：匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>：匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>：匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>：只匹配一个模式。</li>
<li><code>!(pattern-list)</code>：匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div class="highlight"><pre><span></span><code>$ ls abc?<span class="o">(</span>.<span class="o">)</span>txt
abctxt abc.txt
</code></pre></div>

<p>上面例子中，<code>?(.)</code>匹配零个或一个点。</p>
<div class="highlight"><pre><span></span><code>$ ls abc?<span class="o">(</span>def<span class="o">)</span>
abc abcdef
</code></pre></div>

<p>上面例子中，<code>?(def)</code>匹配零个或一个<code>def</code>。</p>
<div class="highlight"><pre><span></span><code>$ ls abc+<span class="o">(</span>.txt<span class="p">|</span>.php<span class="o">)</span>
abc.php abc.txt
</code></pre></div>

<p>上面例子中，<code>+(.txt|.php)</code>匹配文件有一个<code>.txt</code>或<code>.php</code>后缀名。</p>
<div class="highlight"><pre><span></span><code>$ ls abc+<span class="o">(</span>.txt<span class="o">)</span>
abc.txt abc.txt.txt
</code></pre></div>

<p>上面例子中，<code>+(.txt)</code>匹配文件有一个或多个<code>.txt</code>后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 没有 abc 开头的文件名</span>
$ ls abc?<span class="o">(</span>def<span class="o">)</span>
ls: 无法访问<span class="s1">&#39;abc?(def)&#39;</span>: 没有那个文件或目录
</code></pre></div>

<p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code>就原样输出，导致<code>ls</code>命令报错。</p>
<h2 id="shopt">shopt 命令</h2>
<p><code>shopt</code>命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code>命令的使用方法如下。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 打开某个参数</span>
$ <span class="nb">shopt</span> -s <span class="o">[</span>optionname<span class="o">]</span>

<span class="c1"># 关闭某个参数</span>
$ <span class="nb">shopt</span> -u <span class="o">[</span>optionname<span class="o">]</span>

<span class="c1"># 查询某个参数关闭还是打开</span>
$ <span class="nb">shopt</span> <span class="o">[</span>optionname<span class="o">]</span>
</code></pre></div>

<p><strong>（1）dotglob 参数</strong></p>
<p><code>dotglob</code>参数可以让扩展结果包括隐藏文件（即点开头的文件）。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div class="highlight"><pre><span></span><code>$ ls *
abc.txt
</code></pre></div>

<p>打开<code>dotglob</code>，就会包括隐藏文件。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -s dotglob
$ ls *
abc.txt .config
</code></pre></div>

<p><strong>（2）nullglob 参数</strong></p>
<p><code>nullglob</code>参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div class="highlight"><pre><span></span><code>$ rm b*
rm: 无法删除<span class="s1">&#39;b*&#39;</span>: 没有那个文件或目录
</code></pre></div>

<p>上面例子中，由于当前目录不包括<code>b</code>开头的文件名，导致<code>b*</code>不会发生文件名扩展，保持原样不变，所以<code>rm</code>命令报错没有<code>b*</code>这个文件。</p>
<p>打开<code>nullglob</code>参数，就可以让不匹配的通配符返回空字符串。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -s nullglob
$ rm b*
rm: 缺少操作数
</code></pre></div>

<p>上面例子中，由于没有<code>b*</code>匹配的文件名，所以<code>rm b*</code>扩展成了<code>rm</code>，导致报错变成了”缺少操作数“。</p>
<p><strong>（3）failglob 参数</strong></p>
<p><code>failglob</code>参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -s failglob
$ rm b*
bash: 无匹配: b*
</code></pre></div>

<p>上面例子中，打开<code>failglob</code>以后，由于<code>b*</code>不匹配任何文件名，Bash 直接报错了，不再让<code>rm</code>命令去处理。</p>
<p><strong>（4）extglob 参数</strong></p>
<p><code>extglob</code>参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> extglob
extglob         on
</code></pre></div>

<p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -u extglob
</code></pre></div>

<p><strong>（5）nocaseglob 参数</strong></p>
<p><code>nocaseglob</code>参数可以让通配符扩展不区分大小写。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -s nocaseglob
$ ls /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span class="o">(</span>x86<span class="o">)</span>
</code></pre></div>

<p>上面例子中，打开<code>nocaseglob</code>以后，<code>program*</code>就不区分大小写了，可以匹配<code>ProgramData</code>等。</p>
<p><strong>（6）globstar 参数</strong></p>
<p><code>globstar</code>参数可以使得<code>**</code>匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div class="highlight"><pre><span></span><code>a.txt
sub1/b.txt
sub1/sub2/c.txt
</code></pre></div>

<p>上面的文件结构中，顶层目录、第一级子目录<code>sub1</code>、第二级子目录<code>sub1\sub2</code>里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？</p>
<p>默认情况下，只能写成下面这样。</p>
<div class="highlight"><pre><span></span><code>$ ls *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre></div>

<p>这是因为<code>*</code>只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开<code>globstar</code>参数以后，<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>就可以得到想要的结果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -s globstar
$ ls **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre></div>

<h2 id="_22">参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab">Think You Understand Wildcards? Think Again</a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
<h1 id="_23">引号和转义</h1>
<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>
<h2 id="_24">转义</h2>
<p>某些字符在 Bash 里面有特殊含义（比如<code>$</code>、<code>&amp;</code>、<code>*</code>）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$date</span>

$
</code></pre></div>

<p>上面例子中，输出<code>$date</code>不会有任何结果，因为<code>$</code>是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="se">\$</span>date
<span class="nv">$date</span>
</code></pre></div>

<p>上面命令中，只有在特殊字符<code>$</code>前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（<code>\\</code>）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="se">\\</span>
<span class="se">\</span>
</code></pre></div>

<p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>：响铃</li>
<li><code>\b</code>：退格</li>
<li><code>\n</code>：换行</li>
<li><code>\r</code>：回车</li>
<li><code>\t</code>：制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> a<span class="se">\t</span>b
atb

$ <span class="nb">echo</span> -e <span class="s2">&quot;a\tb&quot;</span>
a        b
</code></pre></div>

<p>上面例子中，命令行直接输出不可打印字符，Bash 不能正确解释。必须把它们放在引号之中，然后使用<code>echo</code>命令的<code>-e</code>参数。</p>
<p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p>
<div class="highlight"><pre><span></span><code>$ mv <span class="se">\</span>
/path/to/foo <span class="se">\</span>
/path/to/bar

<span class="c1"># 等同于</span>
$ mv /path/to/foo /path/to/bar
</code></pre></div>

<p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="_25">单引号</h2>
<p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（<code>*</code>）、美元符号（<code>$</code>）、反斜杠（<code>\</code>）等。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s1">&#39;*&#39;</span>
*

$ <span class="nb">echo</span> <span class="s1">&#39;$USER&#39;</span>
<span class="nv">$USER</span>

$ <span class="nb">echo</span> <span class="s1">&#39;$((2+2))&#39;</span>
<span class="k">$((</span><span class="m">2</span><span class="o">+</span><span class="m">2</span><span class="k">))</span>

$ <span class="nb">echo</span> <span class="s1">&#39;$(echo foo)&#39;</span>
<span class="k">$(</span><span class="nb">echo</span> foo<span class="k">)</span>
</code></pre></div>

<p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（<code>$</code>），然后再对里层的单引号转义。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 不正确</span>
$ <span class="nb">echo</span> it<span class="s1">&#39;s</span>

<span class="s1"># 不正确</span>
<span class="s1">$ echo &#39;</span>it<span class="se">\&#39;</span>s<span class="s1">&#39;</span>

<span class="s1"># 正确</span>
<span class="s1">$ echo $&#39;</span>it<span class="se">\&#39;</span>s<span class="err">&#39;</span>
</code></pre></div>

<p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;it&#39;s&quot;</span>
it<span class="err">&#39;</span>s
</code></pre></div>

<h2 id="_26">双引号</h2>
<p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外：美元符号（<code>$</code>）、反引号（<code>`</code>）和反斜杠（<code>\</code>）。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;*&quot;</span>
*
</code></pre></div>

<p>上面例子中，通配符<code>*</code>放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$SHELL</span><span class="s2">&quot;</span>
/bin/bash

$ <span class="nb">echo</span> <span class="s2">&quot;`date`&quot;</span>
Mon Jan <span class="m">27</span> <span class="m">13</span>:33:18 CST <span class="m">2020</span>
</code></pre></div>

<p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;I&#39;d say: \&quot;hello!\&quot;&quot;</span>
I<span class="err">&#39;</span>d say: <span class="s2">&quot;hello!&quot;</span>

$ <span class="nb">echo</span> <span class="s2">&quot;\\&quot;</span>
<span class="se">\</span>
</code></pre></div>

<p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;hello</span>
<span class="s2">world&quot;</span>
hello
world
</code></pre></div>

<p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code>命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p>
<div class="highlight"><pre><span></span><code>$ ls <span class="s2">&quot;two words.txt&quot;</span>
</code></pre></div>

<p>上面命令中，<code>two words.txt</code>是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;this is a     test&quot;</span>
this is a     <span class="nb">test</span>
</code></pre></div>

<p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 单行输出</span>
$ <span class="nb">echo</span> <span class="k">$(</span>cal<span class="k">)</span>
一月 <span class="m">2020</span> 日 一 二 三 四 五 六 <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> ... <span class="m">31</span>

<span class="c1"># 原始格式输出</span>
$ <span class="nb">echo</span> <span class="s2">&quot;</span><span class="k">$(</span>cal<span class="k">)</span><span class="s2">&quot;</span>
      一月 <span class="m">2020</span>
日 一 二 三 四 五 六
          <span class="m">1</span>  <span class="m">2</span>  <span class="m">3</span>  <span class="m">4</span>
 <span class="m">5</span>  <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span> <span class="m">11</span>
<span class="m">12</span> <span class="m">13</span> <span class="m">14</span> <span class="m">15</span> <span class="m">16</span> <span class="m">17</span> <span class="m">18</span>
<span class="m">19</span> <span class="m">20</span> <span class="m">21</span> <span class="m">22</span> <span class="m">23</span> <span class="m">24</span> <span class="m">25</span>
<span class="m">26</span> <span class="m">27</span> <span class="m">28</span> <span class="m">29</span> <span class="m">30</span> <span class="m">31</span>
</code></pre></div>

<p>上面例子中，如果<code>$(cal)</code>不放在双引号之中，<code>echo</code>就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="here">Here 文档</h2>
<p>Here 文档（here document）是一种输入多行字符串的方法，格式如下。</p>
<div class="highlight"><pre><span></span><code><span class="s">&lt;&lt; token</span>
<span class="s">text</span>
<span class="s">token</span>
</code></pre></div>

<p>它的格式分成开始标记（<code>&lt;&lt; token</code>）和结束标记（<code>token</code>）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取；结束标记是单独一行的 Here 文档名称。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<div class="highlight"><pre><span></span><code>$ cat <span class="s">&lt;&lt; _EOF_</span>
<span class="s">&lt;html&gt;</span>
<span class="s">&lt;head&gt;</span>
<span class="s">    &lt;title&gt;</span>
<span class="s">    The title of your page</span>
<span class="s">    &lt;/title&gt;</span>
<span class="s">&lt;/head&gt;</span>

<span class="s">&lt;body&gt;</span>
<span class="s">    Your page content goes here.</span>
<span class="s">&lt;/body&gt;</span>
<span class="s">&lt;/html&gt;</span>
<span class="s">_EOF_</span>
</code></pre></div>

<p>Here 文档内部会发生变量替换和通配符扩展，但是双引号和单引号都失去语法作用，变成了普通字符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="s1">&#39;hello world&#39;</span>
$ cat <span class="s">&lt;&lt; _example_</span>
<span class="s">$foo</span>
<span class="s">&quot;$foo&quot;</span>
<span class="s">&#39;$foo&#39;</span>
<span class="s">_example_</span>

hello world
<span class="s2">&quot;hello world&quot;</span>
<span class="s1">&#39;hello world&#39;</span>
</code></pre></div>

<p>上面例子中，变量<code>$foo</code>发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换和通配符扩展，可以把 Here 文档的开始标记放在单引号之中。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="s1">&#39;hello world&#39;</span>
$ cat <span class="s">&lt;&lt; &#39;_example_&#39;</span>
<span class="s">$foo</span>
<span class="s">&quot;$foo&quot;</span>
<span class="s">&#39;$foo&#39;</span>
<span class="s">_example_</span>

<span class="nv">$foo</span>
<span class="s2">&quot;</span><span class="nv">$foo</span><span class="s2">&quot;</span>
<span class="s1">&#39;$foo&#39;</span>
</code></pre></div>

<p>上面例子中，Here 文档的开始标记（<code>_example_</code>）放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了<code>echo</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">command</span> <span class="s">&lt;&lt; token</span>
<span class="s">  string</span>
<span class="s">token</span>

<span class="c1"># 等同于</span>

$ <span class="nb">echo</span> string <span class="p">|</span> <span class="nb">command</span>
</code></pre></div>

<p>上面代码中，Here 文档相当于<code>echo</code>命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如<code>echo</code>命令就不能用 Here 文档作为参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s">&lt;&lt; _example_</span>
<span class="s">hello</span>
<span class="s">_example_</span>
</code></pre></div>

<p>上面例子不会有任何输出，因为 Here 文档对于<code>echo</code>命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="here_1">Here 字符串</h2>
<p>Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（<code>&lt;&lt;&lt;</code>）表示。</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;&lt;&lt;</span> string
</code></pre></div>

<p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如<code>cat</code>命令只接受标准输入传入的字符串。</p>
<div class="highlight"><pre><span></span><code>$ cat <span class="o">&lt;&lt;&lt;</span> <span class="s1">&#39;hi there&#39;</span>
<span class="c1"># 等同于</span>
$ <span class="nb">echo</span> <span class="s1">&#39;hi there&#39;</span> <span class="p">|</span> cat
</code></pre></div>

<p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<div class="highlight"><pre><span></span><code>$ md5sum <span class="o">&lt;&lt;&lt;</span> <span class="s1">&#39;ddd&#39;</span>
<span class="c1"># 等同于</span>
$ <span class="nb">echo</span> <span class="s1">&#39;ddd&#39;</span> <span class="p">|</span> md5sum
</code></pre></div>

<p>上面例子中，<code>md5sum</code>命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即<code>md5sum ddd</code>里面的<code>ddd</code>会被解释成文件名。这时就可以用 Here 字符串，将字符串传给<code>md5sum</code>命令。</p>
<h1 id="bash_3">Bash 变量</h1>
<p>Bash 变量分成环境变量和自定义变量两类。</p>
<h2 id="_27">简介</h2>
<p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code>命令或<code>printenv</code>命令，可以显示所有环境变量。</p>
<div class="highlight"><pre><span></span><code>$ env
<span class="c1"># 或者</span>
$ printenv
</code></pre></div>

<p>下面是一些常见的环境变量。</p>
<ul>
<li><code>BASHPID</code>：Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>：当前 Shell 的参数，可以用<code>shopt</code>命令修改。</li>
<li><code>DISPLAY</code>：图形环境的显示器名字，通常是<code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>：默认的文本编辑器。</li>
<li><code>HOME</code>：用户的主目录。</li>
<li><code>HOST</code>：当前主机的名称。</li>
<li><code>IFS</code>：词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>：字符集以及语言编码，比如<code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>：Shell 提示符。</li>
<li><code>PS2</code>： 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>：当前工作目录。</li>
<li><code>RANDOM</code>：返回一个0到32767之间的随机数。</li>
<li><code>SHELL</code>：Shell 的名字。</li>
<li><code>SHELLOPTS</code>：启动当前 Shell 的<code>set</code>命令的参数，参见《set 命令》一章。</li>
<li><code>TERM</code>：终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>：当前用户的 ID 编号。</li>
<li><code>USER</code>：当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<p>注意，Bash 变量名区分大小写，<code>HOME</code>和<code>home</code>是两个不同的变量。</p>
<p>查看单个环境变量的值，可以使用<code>printenv</code>命令或<code>echo</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ printenv PATH
<span class="c1"># 或者</span>
$ <span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div>

<p>注意，<code>printenv</code>命令后面的变量名，不用加前缀<code>$</code>。</p>
<p>自定义变量是用户在当前 Shell 里面自己定义的变量，必须先定义后使用，而且仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code>命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">set</span>
</code></pre></div>

<h2 id="_28">创建变量</h2>
<p>用户创建变量的时候，变量名必须遵守下面的规则。</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不允许出现空格和标点符号。</li>
</ul>
<p>变量声明的语法如下。</p>
<div class="highlight"><pre><span></span><code><span class="nv">variable</span><span class="o">=</span>value
</code></pre></div>

<p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<div class="highlight"><pre><span></span><code><span class="nv">myvar</span><span class="o">=</span><span class="s2">&quot;hello world&quot;</span>
</code></pre></div>

<p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<div class="highlight"><pre><span></span><code><span class="nv">a</span><span class="o">=</span>z                     <span class="c1"># 变量 a 赋值为字符串 z</span>
<span class="nv">b</span><span class="o">=</span><span class="s2">&quot;a string&quot;</span>            <span class="c1"># 变量值包含空格，就必须放在引号里面</span>
<span class="nv">c</span><span class="o">=</span><span class="s2">&quot;a string and </span><span class="nv">$b</span><span class="s2">&quot;</span>     <span class="c1"># 变量值可以引用其他变量的值</span>
<span class="nv">d</span><span class="o">=</span><span class="s2">&quot;\t\ta string\n&quot;</span>      <span class="c1"># 变量值可以使用转义字符</span>
<span class="nv">e</span><span class="o">=</span><span class="k">$(</span>ls -l foo.txt<span class="k">)</span>      <span class="c1"># 变量值可以是命令的执行结果</span>
<span class="nv">f</span><span class="o">=</span><span class="k">$((</span><span class="m">5</span> <span class="o">*</span> <span class="m">7</span><span class="k">))</span>            <span class="c1"># 变量值可以是数学运算的结果</span>
</code></pre></div>

<p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="m">1</span>
$ <span class="nv">foo</span><span class="o">=</span><span class="m">2</span>
$ <span class="nb">echo</span> <span class="nv">$foo</span>
<span class="m">2</span>
</code></pre></div>

<p>上面例子中，变量<code>foo</code>的第二次赋值会覆盖第一次赋值。</p>
<h2 id="_29">读取变量</h2>
<p>读取变量的时候，直接在变量名前加上<code>$</code>就可以了。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span>bar
$ <span class="nb">echo</span> <span class="nv">$foo</span>
bar
</code></pre></div>

<p>每当 Shell 看到以<code>$</code>开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于<code>$</code>在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> The total is <span class="nv">$100</span>.00
The total is <span class="m">00</span>.00
</code></pre></div>

<p>上面命令的原意是输入<code>$100</code>，但是 Bash 将<code>$1</code>解释成了变量，该变量为空，因此输入就变成了<code>00.00</code>。所以，如果要使用<code>$</code>的原义，需要在<code>$</code>前面放上反斜杠，进行转义。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> The total is <span class="se">\$</span><span class="m">100</span>.00
The total is <span class="nv">$100</span>.00
</code></pre></div>

<p>读取变量的时候，变量名也可以使用花括号<code>{}</code>包围，比如<code>$a</code>也可以写成<code>${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">a</span><span class="o">=</span>foo
$ <span class="nb">echo</span> <span class="nv">$a_file</span>

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">a</span><span class="si">}</span>_file
foo_file
</code></pre></div>

<p>上面代码中，变量名<code>a_file</code>不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分<code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法<code>$foo</code>，可以看作是<code>${foo}</code>的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用<code>${!varname}</code>的语法，读取最终的值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">myvar</span><span class="o">=</span>USER
$ <span class="nb">echo</span> <span class="si">${</span><span class="p">!myvar</span><span class="si">}</span>
ruanyf
</code></pre></div>

<p>上面的例子中，变量<code>myvar</code>的值是<code>USER</code>，<code>${!myvar}</code>的写法将其展开成最终的值。</p>
<h2 id="_30">删除变量</h2>
<p><code>unset</code>命令用来删除一个变量。</p>
<div class="highlight"><pre><span></span><code><span class="nb">unset</span> NAME
</code></pre></div>

<p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
$ <span class="nv">foo</span><span class="o">=</span>
</code></pre></div>

<p>上面两种写法，都是删除了变量<code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h2 id="export">输出变量，export 命令</h2>
<p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用<code>export</code>命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code>命令用来向子 Shell 输出变量。</p>
<div class="highlight"><pre><span></span><code><span class="nv">NAME</span><span class="o">=</span>foo
<span class="nb">export</span> NAME
</code></pre></div>

<p>上面命令输出了变量<code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<div class="highlight"><pre><span></span><code><span class="nb">export</span> <span class="nv">NAME</span><span class="o">=</span>value
</code></pre></div>

<p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量<code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 输出变量 $foo</span>
$ <span class="nb">export</span> <span class="nv">foo</span><span class="o">=</span>bar

<span class="c1"># 新建子 Shell</span>
$ bash

<span class="c1"># 读取 $foo</span>
$ <span class="nb">echo</span> <span class="nv">$foo</span>
bar

<span class="c1"># 修改继承的变量</span>
$ <span class="nv">foo</span><span class="o">=</span>baz

<span class="c1"># 退出子 Shell</span>
$ <span class="nb">exit</span>

<span class="c1"># 读取 $foo</span>
$ <span class="nb">echo</span> <span class="nv">$foo</span>
bar
</code></pre></div>

<p>上面例子中，子 Shell 修改了继承的变量<code>$foo</code>，对父 Shell 没有影响。</p>
<h2 id="_31">特殊变量</h2>
<p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<p>（1）<code>$?</code></p>
<p><code>$?</code>为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是<code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>
<div class="highlight"><pre><span></span><code>$ ls doesnotexist
ls: doesnotexist: No such file or directory

$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</code></pre></div>

<p>上面例子中，<code>ls</code>命令查看一个不存在的文件，导致报错。<code>$?</code>为1，表示上一个命令执行失败。</p>
<p>（2）<code>$$</code></p>
<p><code>$$</code>为当前 Shell 的进程 ID。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$$</span>
<span class="m">10662</span>
</code></pre></div>

<p>这个特殊变量可以用来命名临时文件。</p>
<div class="highlight"><pre><span></span><code><span class="nv">LOGFILE</span><span class="o">=</span>/tmp/output_log.<span class="nv">$$</span>
</code></pre></div>

<p>（3）<code>$_</code></p>
<p><code>$_</code>为上一个命令的最后一个参数。</p>
<div class="highlight"><pre><span></span><code>$ grep dictionary /usr/share/dict/words
dictionary

$ <span class="nb">echo</span> <span class="nv">$_</span>
/usr/share/dict/words
</code></pre></div>

<p>（4）<code>$!</code></p>
<p><code>$!</code>为最近一个后台执行的异步命令的进程 ID。</p>
<div class="highlight"><pre><span></span><code>$ firefox <span class="p">&amp;</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span> <span class="m">11064</span>

$ <span class="nb">echo</span> <span class="nv">$!</span>
<span class="m">11064</span>
</code></pre></div>

<p>上面例子中，<code>firefox</code>是后台运行的命令，<code>$!</code>返回该命令的进程 ID。</p>
<p>（5）<code>$0</code></p>
<p><code>$0</code>为当前 Shell 的名称（在命令行直接执行是）或者脚本名（在脚本中执行时）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$0</span>
bash
</code></pre></div>

<p>上面例子中，<code>$0</code>返回当前运行的是 Bash。</p>
<p>（6）<code>$-</code></p>
<p><code>$-</code>为当前 Shell 的启动参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$-</span>
himBHs
</code></pre></div>

<p>（7）<code>$@</code>和<code>$#</code></p>
<p><code>$@</code>和<code>$#</code>表示脚本的参数数量，参见脚本一章。</p>
<h2 id="_32">变量的默认值</h2>
<p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<div class="highlight"><pre><span></span><code><span class="si">${</span><span class="nv">varname</span><span class="k">:-</span><span class="nv">word</span><span class="si">}</span>
</code></pre></div>

<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则返回<code>word</code>。它的目的是返回一个默认值，比如<code>${count:-0}</code>表示变量<code>count</code>不存在时返回<code>0</code>。</p>
<div class="highlight"><pre><span></span><code><span class="si">${</span><span class="nv">varname</span><span class="p">:=word</span><span class="si">}</span>
</code></pre></div>

<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则将它设为<code>word</code>，并且返回<code>word</code>。它的目的是设置变量的默认值，比如<code>${count:=0}</code>表示变量<code>count</code>不存在时返回<code>0</code>，且将<code>count</code>设为<code>0</code>。</p>
<div class="highlight"><pre><span></span><code><span class="si">${</span><span class="nv">varname</span><span class="p">:+word</span><span class="si">}</span>
</code></pre></div>

<p>上面语法的含义是，如果变量名存在且不为空，则返回<code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如<code>${count:+1}</code>表示变量<code>count</code>存在时返回<code>1</code>（表示<code>true</code>），否则返回空值。</p>
<div class="highlight"><pre><span></span><code><span class="si">${</span><span class="nv">varname</span><span class="p">:?message</span><span class="si">}</span>
</code></pre></div>

<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则打印出<code>varname: message</code>，并中断脚本的执行。如果省略了<code>message</code>，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如<code>${count:?"undefined!"}</code>表示变量<code>count</code>未定义时就中断执行，抛出错误，返回给定的报错信息<code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用到数字<code>1</code>到<code>9</code>，表示脚本的参数。</p>
<div class="highlight"><pre><span></span><code><span class="nv">filename</span><span class="o">=</span><span class="si">${</span><span class="nv">1</span><span class="p">:?</span><span class="s2">&quot;filename missing.&quot;</span><span class="si">}</span>
</code></pre></div>

<p>上面代码出现在脚本中，<code>1</code>表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h2 id="declare">declare 命令</h2>
<p><code>declare</code>命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<div class="highlight"><pre><span></span><code><span class="nb">declare</span> OPTION <span class="nv">VARIABLE</span><span class="o">=</span>value
</code></pre></div>

<p><code>declare</code>命令的主要参数（OPTION）如下。</p>
<ul>
<li><code>-a</code>：声明数组变量。</li>
<li><code>-f</code>：输出所有函数定义。</li>
<li><code>-F</code>：输出所有函数名。</li>
<li><code>-i</code>：声明整数变量。</li>
<li><code>-l</code>：声明变量为小写字母。</li>
<li><code>-p</code>：查看变量信息。</li>
<li><code>-r</code>：声明只读变量。</li>
<li><code>-u</code>：声明变量为大写字母。</li>
<li><code>-x</code>：该变量输出为环境变量。</li>
</ul>
<p><code>declare</code>命令如果用在函数中，声明的变量只在函数内部有效，等同于<code>local</code>命令。</p>
<p>不带任何参数时，<code>declare</code>命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的<code>set</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span>
</code></pre></div>

<p><strong>（1）<code>-i</code>参数</strong></p>
<p><code>-i</code>参数声明整数变量以后，可以直接进行数学运算。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -i <span class="nv">val1</span><span class="o">=</span><span class="m">12</span> <span class="nv">val2</span><span class="o">=</span><span class="m">5</span>
$ <span class="nb">declare</span> -i result
$ <span class="nv">result</span><span class="o">=</span>val1*val2
$ <span class="nb">echo</span> <span class="nv">$result</span>
<span class="m">60</span>
</code></pre></div>

<p>上面例子中，如果变量<code>result</code>不声明为整数，<code>val1*val2</code>会被当作字面量，不会进行整数运算。另外，<code>val1</code>和<code>val2</code>其实不需要声明为整数，因为只要<code>result</code>声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -i <span class="nv">val</span><span class="o">=</span><span class="m">12</span>
$ <span class="nv">var</span><span class="o">=</span>foo
$ <span class="nb">echo</span> <span class="nv">$var</span>
foo
</code></pre></div>

<p>上面例子中，变量<code>foo</code>声明为整数，但是覆盖以后，就变成了字符串，Bash 不会报错。</p>
<p><strong>（2）<code>-x</code>参数</strong></p>
<p><code>-x</code>参数等同于<code>export</code>命令，可以输出一个变量为子 Shell 的环境变量。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -x foo
<span class="c1"># 等同于</span>
$ <span class="nb">export</span> foo
</code></pre></div>

<p><strong>（3）<code>-r</code>参数</strong></p>
<p><code>-r</code>参数可以声明只读变量，无法改变变量值，也不能<code>unset</code>变量。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -r <span class="nv">bar</span><span class="o">=</span><span class="m">1</span>

$ <span class="nv">bar</span><span class="o">=</span><span class="m">2</span>
bash: bar：只读变量
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>

$ <span class="nb">unset</span> bar
bash: bar：只读变量
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</code></pre></div>

<p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<p><strong>（4）<code>-u</code>参数</strong></p>
<p><code>-u</code>参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -u foo
$ <span class="nv">foo</span><span class="o">=</span>upper
$ <span class="nb">echo</span> <span class="nv">$foo</span>
UPPER
</code></pre></div>

<p><strong>（5）<code>-l</code>参数</strong></p>
<p><code>-l</code>参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -l bar
$ <span class="nv">bar</span><span class="o">=</span>LOWER
$ <span class="nb">echo</span> <span class="nv">$bar</span>
lower
</code></pre></div>

<p><strong>（6）<code>-p</code>参数</strong></p>
<p><code>-p</code>参数输出变量信息。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span>hello
$ <span class="nb">declare</span> -p foo
<span class="nb">declare</span> -- <span class="nv">foo</span><span class="o">=</span><span class="s2">&quot;hello&quot;</span>
$ <span class="nb">declare</span> -p bar
bar：未找到
</code></pre></div>

<p>上面例子中，<code>declare -p</code>可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declear -p</code>输出所有变量的信息。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -p
</code></pre></div>

<p><strong>（7）<code>-f</code>参数</strong></p>
<p><code>-f</code>参数输出当前环境的所有函数，包括它的定义。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -f
</code></pre></div>

<p><strong>（8）<code>-F</code>参数</strong></p>
<p><code>-F</code>参数输出当前环境的所有函数名，不包含函数定义。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -F
</code></pre></div>

<h2 id="readonly">readonly 命令</h2>
<p><code>readonly</code>命令等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">readonly</span> <span class="nv">foo</span><span class="o">=</span><span class="m">1</span>
$ <span class="nv">foo</span><span class="o">=</span><span class="m">2</span>
bash: foo：只读变量
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</code></pre></div>

<p>上面例子中，更改只读变量<code>foo</code>会报错，命令执行失败。</p>
<p><code>readonly</code>命令有三个参数。</p>
<ul>
<li><code>-f</code>：声明的变量为函数名。</li>
<li><code>-p</code>：打印出所有的只读变量。</li>
<li><code>-a</code>：声明的变量为数组。</li>
</ul>
<h2 id="let">let 命令</h2>
<p><code>let</code>命令声明变量时，可以直接执行算术表达式。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">let</span> <span class="nv">foo</span><span class="o">=</span><span class="m">1</span>+2
$ <span class="nb">echo</span> <span class="nv">$foo</span>
<span class="m">3</span>
</code></pre></div>

<p>上面例子中，<code>let</code>命令可以直接计算<code>1 + 2</code>。</p>
<p><code>let</code>命令的参数表达式如果包含空格，就需要使用引号。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">let</span> <span class="s2">&quot;foo = 1 + 2&quot;</span>
</code></pre></div>

<p><code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">let</span> <span class="s2">&quot;v1 = 1&quot;</span> <span class="s2">&quot;v2 = v1++&quot;</span>
$ <span class="nb">echo</span> <span class="nv">$v1</span>,<span class="nv">$v2</span>
<span class="m">2</span>,1
</code></pre></div>

<p>上面例子中，<code>let</code>声明了两个变量<code>v1</code>和<code>v2</code>，其中<code>v2</code>等于<code>v1++</code>，表示先返回<code>v1</code>的值，然后<code>v1</code>自增。</p>
<p>这种语法支持的运算符，参考《Bash 的算术运算》一章。</p>
<h1 id="_33">字符串操作</h1>
<p>本章介绍 Bash 字符串操作的语法。</p>
<h2 id="_34">字符串的长度</h2>
<p>获取字符串长度的语法如下。</p>
<div class="highlight"><pre><span></span><code><span class="si">${#</span><span class="nv">varname</span><span class="si">}</span>
</code></pre></div>

<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">myPath</span><span class="o">=</span>/home/cam/book/long.file.name
$ <span class="nb">echo</span> <span class="si">${#</span><span class="nv">myPath</span><span class="si">}</span>
<span class="m">29</span>
</code></pre></div>

<p>大括号<code>{}</code>是必需的，否则 Bash 会将<code>$#</code>理解成脚本的参数个数，将变量名理解成文本。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$#</span>myvar
0myvar
</code></pre></div>

<p>上面例子中，Bash 将<code>$#</code>和<code>myvar</code>分开解释了。</p>
<h2 id="_35">子字符串</h2>
<p>字符串提取子串的语法如下。</p>
<div class="highlight"><pre><span></span><code><span class="si">${</span><span class="nv">varname</span><span class="p">:</span><span class="nv">offset</span><span class="p">:</span><span class="nv">length</span><span class="si">}</span>
</code></pre></div>

<p>上面语法的含义是返回变量<code>$varname</code>的子字符串，从位置<code>offset</code>开始（从<code>0</code>开始计算），长度为<code>length</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">count</span><span class="o">=</span>frogfootman
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">count</span><span class="p">:</span><span class="nv">4</span><span class="p">:</span><span class="nv">4</span><span class="si">}</span>
foot
</code></pre></div>

<p>上面例子返回字符串<code>frogfootman</code>从4号位置开始的长度为4的子字符串<code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 报错</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="s2">&quot;hello&quot;</span><span class="p">:</span><span class="nv">2</span><span class="p">:</span><span class="nv">3</span><span class="si">}</span>
</code></pre></div>

<p>上面例子中，<code>"hello"</code>不是变量名，导致 Bash 报错。</p>
<p>如果省略<code>length</code>，则从位置<code>offset</code>开始，一直返回到字符串的结尾。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">count</span><span class="o">=</span>frogfootman
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">count</span><span class="p">:</span><span class="nv">4</span><span class="si">}</span>
footman
</code></pre></div>

<p>上面例子是返回变量<code>count</code>从4号位置一直到结尾的子字符串。</p>
<p>如果<code>offset</code>为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与<code>${variable:-word}</code>的变量的设置默认值语法混淆。这时，如果还指定<code>length</code>，则<code>length</code>不能小于零。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="s2">&quot;This string is long.&quot;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">: -5</span><span class="si">}</span>
long.
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">: -5:</span><span class="nv">2</span><span class="si">}</span>
lo
</code></pre></div>

<p>上面例子中，<code>offset</code>为<code>-5</code>，表示从倒数第5个字符开始截取，所以返回<code>long.</code>。如果指定长度为<code>2</code>，则返回<code>lo</code>。</p>
<h2 id="_36">搜索和替换</h2>
<p>Bash 提供字符串搜索和替换的多种方法。</p>
<p><strong>（1）字符串头部的模式匹配。</strong></p>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 如果 pattern 匹配变量 variable 的开头，</span>
<span class="c1"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">#pattern</span><span class="si">}</span>

<span class="c1"># 如果 pattern 匹配变量 variable 的开头，</span>
<span class="c1"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">##pattern</span><span class="si">}</span>
</code></pre></div>

<p>上面两种语法会删除变量字符串开头的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。</p>
<p>匹配模式<code>pattern</code>可以使用<code>*</code>、<code>?</code>、<code>[]</code>等通配符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">myPath</span><span class="o">=</span>/home/cam/book/long.file.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">myPath</span><span class="p">#/*/</span><span class="si">}</span>
cam/book/long.file.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">myPath</span><span class="p">##/*/</span><span class="si">}</span>
long.file.name
</code></pre></div>

<p>上面例子中，匹配的模式是<code>/*/</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>/home/</code>，最长匹配是<code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">path</span><span class="o">=</span>/home/cam/book/long.file.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">##*/</span><span class="si">}</span>
long.file.name
</code></pre></div>

<p>上面例子中，模式<code>*/</code>匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">phone</span><span class="o">=</span><span class="s2">&quot;555-456-1414&quot;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">phone</span><span class="p">#*-</span><span class="si">}</span>
<span class="m">456</span>-1414
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">phone</span><span class="p">##*-</span><span class="si">}</span>
<span class="m">1414</span>
</code></pre></div>

<p>如果匹配不成功，则返回原始字符串。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">phone</span><span class="o">=</span><span class="s2">&quot;555-456-1414&quot;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">phone</span><span class="p">#444</span><span class="si">}</span>
<span class="m">555</span>-456-1414
</code></pre></div>

<p>上面例子中，原始字符串里面无法匹配模式<code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 模式必须出现在字符串的开头</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">/#pattern/string</span><span class="si">}</span>

<span class="c1"># 示例</span>
$ <span class="nv">foo</span><span class="o">=</span>JPG.JPG
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">/#JPG/jpg</span><span class="si">}</span>
jpg.JPG
</code></pre></div>

<p>上面例子中，被替换的<code>JPG</code>必须出现在字符串头部，所以返回<code>jpg.JPG</code>。</p>
<p><strong>（2）字符串尾部的模式匹配。</strong></p>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 如果 pattern 匹配变量 variable 的结尾，</span>
<span class="c1"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">%pattern</span><span class="si">}</span>

<span class="c1"># 如果 pattern 匹配变量 variable 的结尾，</span>
<span class="c1"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">%%pattern</span><span class="si">}</span>
</code></pre></div>

<p>上面两种语法会删除变量字符串结尾的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">path</span><span class="o">=</span>/home/cam/book/long.file.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">%.*</span><span class="si">}</span>
/home/cam/book/long.file

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">%%.*</span><span class="si">}</span>
/home/cam/book/long
</code></pre></div>

<p>上面例子中，匹配模式是<code>.*</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>.name</code>，最长匹配是<code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">path</span><span class="o">=</span>/home/cam/book/long.file.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">%/*</span><span class="si">}</span>
/home/cam/book
</code></pre></div>

<p>上面例子中，模式<code>/*</code>匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">file</span><span class="o">=</span>foo.png
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">file</span><span class="p">%.png</span><span class="si">}</span>.jpg
foo.jpg
</code></pre></div>

<p>上面的例子将文件的后缀名，从<code>.png</code>改成了<code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">phone</span><span class="o">=</span><span class="s2">&quot;555-456-1414&quot;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">phone</span><span class="p">%-*</span><span class="si">}</span>
<span class="m">555</span>-456
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">phone</span><span class="p">%%-*</span><span class="si">}</span>
<span class="m">555</span>
</code></pre></div>

<p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 模式必须出现在字符串的结尾</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">/%pattern/string</span><span class="si">}</span>

<span class="c1"># 示例</span>
$ <span class="nv">foo</span><span class="o">=</span>JPG.JPG
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">/%JPG/jpg</span><span class="si">}</span>
JPG.jpg
</code></pre></div>

<p>上面例子中，被替换的<code>JPG</code>必须出现在字符串尾部，所以返回<code>JPG.jpg</code>。</p>
<p><strong>（3）任意位置的模式匹配。</strong></p>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 如果 pattern 匹配变量 variable 的一部分，</span>
<span class="c1"># 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">/pattern/string</span><span class="si">}</span>

<span class="c1"># 如果 pattern 匹配变量 variable 的一部分，</span>
<span class="c1"># 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">//pattern/string</span><span class="si">}</span>
</code></pre></div>

<p>上面两种语法都是最长匹配（贪婪匹配）下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">path</span><span class="o">=</span>/home/cam/foo/foo.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">/foo/bar</span><span class="si">}</span>
/home/cam/bar/foo.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">//foo/bar</span><span class="si">}</span>
/home/cam/bar/bar.name
</code></pre></div>

<p>上面例子中，前一个命令只替换了第一个<code>foo</code>，后一个命令将两个<code>foo</code>都替换了。</p>
<p>下面的例子将分隔符从<code>:</code>换成换行符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> -e <span class="si">${</span><span class="nv">PATH</span><span class="p">//:/</span><span class="s1">&#39;\n&#39;</span><span class="si">}</span>
/usr/local/bin
/usr/bin
/bin
...
</code></pre></div>

<p>上面例子中，<code>echo</code>命令的<code>-e</code>参数，表示将替换后的字符串的<code>\n</code>字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">phone</span><span class="o">=</span><span class="s2">&quot;555-456-1414&quot;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">phone</span><span class="p">/5?4/-</span><span class="si">}</span>
<span class="m">55</span>-56-1414
</code></pre></div>

<p>上面的例子将<code>5-4</code>替换成<code>-</code>。</p>
<p>如果省略了<code>string</code>部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">path</span><span class="o">=</span>/home/cam/foo/foo.name

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">path</span><span class="p">/.*/</span><span class="si">}</span>
/home/cam/foo/foo
</code></pre></div>

<p>上面例子中，第二个斜杠后面的<code>string</code>部分省略了，所以模式<code>.*</code>匹配的部分<code>.name</code>被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 模式必须出现在字符串的开头</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">/#pattern/string</span><span class="si">}</span>

<span class="c1"># 模式必须出现在字符串的结尾</span>
<span class="si">${</span><span class="nv">variable</span><span class="p">/%pattern/string</span><span class="si">}</span>
</code></pre></div>

<h2 id="_37">改变大小写</h2>
<p>下面的语法可以改变变量的大小写。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 转为大写</span>
<span class="si">${</span><span class="nv">varname</span><span class="p">^^</span><span class="si">}</span>

<span class="c1"># 转为小写</span>
<span class="si">${</span><span class="nv">varname</span><span class="p">,,</span><span class="si">}</span>
</code></pre></div>

<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span>heLLo
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">^^</span><span class="si">}</span>
HELLO
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">,,</span><span class="si">}</span>
hello
</code></pre></div>

<h1 id="bash_4">Bash 的算术运算</h1>
<h2 id="_38">算术表达式</h2>
<p><code>((...))</code>语法可以进行整数的算术运算。</p>
<div class="highlight"><pre><span></span><code>$ <span class="o">((</span><span class="nv">foo</span> <span class="o">=</span> <span class="m">5</span> + <span class="m">5</span><span class="o">))</span>
$ <span class="nb">echo</span> <span class="nv">$foo</span>
<span class="m">10</span>
</code></pre></div>

<p><code>((...))</code>会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="o">((</span><span class="m">2</span>+2<span class="o">))</span>
$ <span class="o">((</span> <span class="m">2</span>+2 <span class="o">))</span>
$ <span class="o">((</span> <span class="m">2</span> + <span class="m">2</span> <span class="o">))</span>
</code></pre></div>

<p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是<code>0</code>，命令就算执行成功。</p>
<div class="highlight"><pre><span></span><code>$ <span class="o">((</span> <span class="m">3</span> + <span class="m">2</span> <span class="o">))</span>
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>
</code></pre></div>

<p>上面例子中，<code>3 + 2</code>的结果是5，命令就算执行成功，环境变量<code>$?</code>为<code>0</code>。</p>
<p>如果算术结果为<code>0</code>，命令就算执行失败。</p>
<div class="highlight"><pre><span></span><code>$ <span class="o">((</span> <span class="m">3</span> - <span class="m">3</span> <span class="o">))</span>
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</code></pre></div>

<p>上面例子中，<code>3 - 3</code>的结果是<code>0</code>，环境变量<code>$?</code>为<code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在<code>((...))</code>前面加上美元符号<code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">2</span> <span class="o">+</span> <span class="m">2</span><span class="k">))</span>
<span class="m">4</span>
</code></pre></div>

<p><code>((...))</code>语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>：加法</li>
<li><code>-</code>：减法</li>
<li><code>*</code>：乘法</li>
<li><code>/</code>：除法（整除）</li>
<li><code>%</code>：余数</li>
<li><code>**</code>：指数</li>
<li><code>++</code>：自增运算（前缀或后缀）</li>
<li><code>--</code>：自减运算（前缀或后缀）</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如<code>5</code>除以<code>2</code>，得到的结果是<code>2</code>，而不是<code>2.5</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">5</span> <span class="o">/</span> <span class="m">2</span><span class="k">))</span>
<span class="m">2</span>
</code></pre></div>

<p><code>++</code>和<code>--</code>这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">i</span><span class="o">=</span><span class="m">0</span>
$ <span class="nb">echo</span> <span class="nv">$i</span>
<span class="m">0</span>
$ <span class="nb">echo</span> <span class="k">$((</span>i++<span class="k">))</span>
<span class="m">0</span>
$ <span class="nb">echo</span> <span class="nv">$i</span>
<span class="m">1</span>
$ <span class="nb">echo</span> <span class="k">$((</span><span class="o">++</span>i<span class="k">))</span>
<span class="m">2</span>
$ <span class="nb">echo</span> <span class="nv">$i</span>
<span class="m">2</span>
</code></pre></div>

<p>上面例子中，<code>++</code>作为后缀是先返回值，执行<code>echo</code>命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行<code>echo</code>命令。</p>
<p><code>$((...))</code>内部可以用圆括号改变运算顺序。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span> <span class="o">(</span><span class="m">2</span> <span class="o">+</span> <span class="m">3</span><span class="o">)</span> <span class="o">*</span> <span class="m">4</span> <span class="k">))</span>
<span class="m">20</span>
</code></pre></div>

<p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code>结构可以嵌套。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="o">(</span><span class="m">5</span><span class="o">**</span><span class="m">2</span><span class="o">)</span> <span class="o">*</span> <span class="m">3</span><span class="k">))</span>
<span class="m">75</span>
<span class="c1"># 等同于</span>
$ <span class="nb">echo</span> <span class="k">$(($((</span><span class="m">5</span><span class="o">**</span><span class="m">2</span><span class="k">))</span> <span class="o">*</span> <span class="m">3</span><span class="k">))</span>
<span class="m">75</span>
</code></pre></div>

<p>这个语法只能计算整数，否则会报错。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 报错</span>
$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">1</span>.5 <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
bash: 语法错误
</code></pre></div>

<p><code>$((...))</code>的圆括号之中，不需要在变量名之前加上<code>$</code>，不过加上也不报错。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">number</span><span class="o">=</span><span class="m">2</span>
$ <span class="nb">echo</span> <span class="k">$((</span><span class="nv">$number</span> <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
<span class="m">3</span>
</code></pre></div>

<p>上面例子中，变量<code>number</code>前面有没有美元符号，结果都是一样的。</p>
<p>如果在<code>$((...))</code>里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span> <span class="s2">&quot;hello&quot;</span> <span class="o">+</span> <span class="m">2</span><span class="k">))</span>
<span class="m">2</span>
$ <span class="nb">echo</span> <span class="k">$((</span> <span class="s2">&quot;hello&quot;</span> <span class="o">*</span> <span class="m">2</span><span class="k">))</span>
<span class="m">0</span>
</code></pre></div>

<p>上面例子中，<code>"hello"</code>会被当作变量名，返回空值，而<code>$((...))</code>会将空值当作<code>0</code>，所以乘法的运算结果就是<code>0</code>。同理，如果<code>$((...))</code>里面使用不存在的变量，也会当作<code>0</code>处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在<code>$((...))</code>里面会被当作空值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span>hello
$ <span class="nb">echo</span> <span class="k">$((</span> foo <span class="o">+</span> <span class="m">2</span><span class="k">))</span>
<span class="m">2</span>
</code></pre></div>

<p>上面例子中，变量<code>foo</code>的值是<code>hello</code>，而<code>hello</code>也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span>hello
$ <span class="nv">hello</span><span class="o">=</span><span class="m">3</span>
$ <span class="nb">echo</span> <span class="k">$((</span> foo <span class="o">+</span> <span class="m">2</span> <span class="k">))</span>
<span class="m">5</span>
</code></pre></div>

<p>上面代码中，<code>foo + 2</code>取决于变量<code>hello</code>的值。</p>
<p>最后，<code>$[...]</code>是以前的语法，也可以做整数运算，不建议使用。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> $<span class="o">[</span><span class="m">2</span>+2<span class="o">]</span>
<span class="m">4</span>
</code></pre></div>

<h2 id="_39">数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>：没有任何特殊表示法的数字是十进制数（以10为底）。</li>
<li><code>0number</code>：八进制数。</li>
<li><code>0xnumber</code>：十六进制数。</li>
<li><code>base#number</code>：<code>base</code>进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">0</span>xff<span class="k">))</span>
<span class="m">255</span>
$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">2#11111111</span><span class="k">))</span>
<span class="m">255</span>
</code></pre></div>

<p>上面例子中，<code>0xff</code>是十六进制数，<code>2#11111111</code>是二进制数。</p>
<h2 id="_40">位运算</h2>
<p><code>$((...))</code>支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>：位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>：位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>：位的“与”运算，对两个数字的所有位执行一个<code>AND</code>操作。</li>
<li><code>|</code>：位的“或”运算，对两个数字的所有位执行一个<code>OR</code>操作。</li>
<li><code>~</code>：位的“否”运算，对一个数字的所有位取反。</li>
<li><code>!</code>：逻辑“否”运算</li>
<li><code>^</code>：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符<code>&gt;&gt;</code>的例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">16</span>&gt;&gt;2<span class="k">))</span>
<span class="m">4</span>
</code></pre></div>

<p>下面是左移运算符<code>&lt;&lt;</code>的例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">16</span>&lt;&lt;<span class="m">2</span><span class="k">))</span>
<span class="m">64</span>
</code></pre></div>

<p>下面是<code>17</code>（二进制<code>10001</code>）和<code>3</code>（二进制<code>11</code>）的各种二进制运算的结果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">17</span><span class="o">&amp;</span><span class="m">3</span><span class="k">))</span>
<span class="m">1</span>
$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">17</span><span class="o">|</span><span class="m">3</span><span class="k">))</span>
<span class="m">19</span>
$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">17</span><span class="o">^</span><span class="m">3</span><span class="k">))</span>
<span class="m">18</span>
</code></pre></div>

<h2 id="_41">逻辑运算</h2>
<p><code>$((...))</code>支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;=</code>：小于或相等</li>
<li><code>&gt;=</code>：大于或相等</li>
<li><code>==</code>：相等</li>
<li><code>!=</code>：不相等</li>
<li><code>&amp;&amp;</code>：逻辑与</li>
<li><code>||</code>：逻辑或</li>
<li><code>expr1?expr2:expr3</code>：三元条件运算符。若表达式<code>expr1</code>的计算结果为非零值（算术真），则执行表达式<code>expr2</code>，否则执行表达式<code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回<code>1</code>，否则返回<code>0</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="m">3</span> &gt; <span class="m">2</span><span class="k">))</span>
<span class="m">1</span>
$ <span class="nb">echo</span> <span class="k">$((</span> <span class="o">(</span><span class="m">3</span> &gt; <span class="m">2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="m">4</span> &lt;<span class="o">=</span> <span class="m">1</span><span class="o">)</span> <span class="k">))</span>
<span class="m">1</span>
</code></pre></div>

<p>三元运算符执行一个单独的逻辑测试。它用起来类似于<code>if/then/else</code>语句。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">a</span><span class="o">=</span><span class="m">0</span>
$ <span class="nb">echo</span> <span class="k">$((</span>a&lt;<span class="m">1</span> ? <span class="m">1</span> : <span class="m">0</span><span class="k">))</span>
<span class="m">1</span>
$ <span class="nb">echo</span> <span class="k">$((</span>a&gt;1 ? <span class="m">1</span> : <span class="m">0</span><span class="k">))</span>
<span class="m">0</span>
</code></pre></div>

<p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="_42">赋值运算</h2>
<p>算术表达式<code>$((...))</code>可以执行赋值运算。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="nv">a</span><span class="o">=</span><span class="m">1</span><span class="k">))</span>
<span class="m">1</span>
$ <span class="nb">echo</span> <span class="nv">$a</span>
<span class="m">1</span>
</code></pre></div>

<p>上面例子中，<code>a=1</code>对变量<code>a</code>进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code>支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>：简单赋值。</li>
<li><code>parameter += value</code>：等价于<code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>：等价于<code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>：等价于<code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>：等价于<code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>：等价于<code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>：等价于<code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>：等价于<code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>：等价于<code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>：等价于<code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>：等价于<code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="m">5</span>
$ <span class="nb">echo</span> <span class="k">$((</span>foo*<span class="o">=</span><span class="m">2</span><span class="k">))</span>
<span class="m">10</span>
</code></pre></div>

<p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span> a&lt;<span class="m">1</span> ? <span class="o">(</span><span class="nv">a</span><span class="o">+=</span><span class="m">1</span><span class="o">)</span> : <span class="o">(</span>a-<span class="o">=</span><span class="m">1</span><span class="o">)</span> <span class="k">))</span>
</code></pre></div>

<h2 id="_43">求值运算</h2>
<p>逗号<code>,</code>在<code>$((...))</code>内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="k">$((</span><span class="nv">foo</span> <span class="o">=</span> <span class="m">1</span> <span class="o">+</span> <span class="m">2</span>, <span class="m">3</span> <span class="o">*</span> <span class="m">4</span><span class="k">))</span>
<span class="m">12</span>
$ <span class="nb">echo</span> <span class="nv">$foo</span>
<span class="m">3</span>
</code></pre></div>

<p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值<code>12</code>。</p>
<h2 id="expr">expr 命令</h2>
<p><code>expr</code>命令支持算术运算，可以不使用<code>((...))</code>语法。</p>
<div class="highlight"><pre><span></span><code>$ expr <span class="m">3</span> + <span class="m">2</span>
<span class="m">5</span>
</code></pre></div>

<p><code>expr</code>命令支持变量替换。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=</span><span class="m">3</span>
$ expr <span class="nv">$foo</span> + <span class="m">2</span>
<span class="m">5</span>
</code></pre></div>

<p><code>expr</code>命令也不支持非整数参数。</p>
<div class="highlight"><pre><span></span><code>$ expr <span class="m">3</span>.5 + <span class="m">2</span>
expr: 非整数参数
</code></pre></div>

<p>上面例子中，如果有非整数的运算，<code>expr</code>命令就报错了。</p>
<h1 id="bash_5">Bash 行操作</h1>
<h2 id="_44">简介</h2>
<p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">set</span> -o vi
</code></pre></div>

<p>下面的命令可以改回 Emacs 快捷键。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">set</span> -o emacs
</code></pre></div>

<p>如果想永久性更改编辑模式（Emacs / Vi），可以将命令写在<code>~/.inputrc</code>文件，这个文件是 Readline 的配置文件。</p>
<div class="highlight"><pre><span></span><code><span class="nb">set</span> editing-mode vi
</code></pre></div>

<p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<div class="highlight"><pre><span></span><code>$ bash --noediting
</code></pre></div>

<p>上面命令中，<code>--noediting</code>参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="_45">光标移动</h2>
<p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>：移到行首。</li>
<li><code>Ctrl + b</code>：向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>：移到行尾。</li>
<li><code>Ctrl + f</code>：向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>：移动到当前单词的词尾。</li>
<li><code>Alt + b</code>：移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="_46">清除屏幕</h2>
<p><code>Ctrl + l</code>快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与<code>clear</code>命令作用相同。</p>
<h2 id="_47">编辑操作</h2>
<p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>：删除光标位置的字符（delete）。</li>
<li><code>Ctrl + w</code>：删除光标前面的单词。</li>
<li><code>Ctrl + t</code>：光标位置的字符与它前面一位的字符交换位置（transpose）。</li>
<li><code>Alt + t</code>：光标位置的词与它前面一位的词交换位置（transpose）。</li>
<li><code>Alt + l</code>：将光标位置至词尾转为小写（lowercase）。</li>
<li><code>Alt + u</code>：将光标位置至词尾转为大写（uppercase）。</li>
</ul>
<p>使用<code>Ctrl + d</code>的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>：剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>：剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>：剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>：剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>：在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="_48">自动补全</h2>
<p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入<code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为<code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以<code>$</code>开头，则按下 Tab 键会补全变量；如果以<code>~</code>开头，则补全用户名；如果以<code>@</code>开头，则补全主机名（hostname），主机名以列在<code>/etc/hosts</code>文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab：完成自动补全。</li>
<li><code>Alt + ?</code>：列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>：尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>：先按<code>Ctrl + x</code>，再按<code>/</code>，等同于<code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>：命令补全。</li>
<li><code>Ctrl + x !</code>：先按<code>Ctrl + x</code>，再按<code>!</code>，等同于<code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>：用户名补全。</li>
<li><code>Ctrl + x ~</code>：先按<code>Ctrl + x</code>，再按<code>~</code>，等同于<code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>：变量名补全。</li>
<li><code>Ctrl + x $</code>：先按<code>Ctrl + x</code>，再按<code>$</code>，等同于<code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>：主机名补全。</li>
<li><code>Ctrl + x @</code>：先按<code>Ctrl + x</code>，再按<code>@</code>，等同于<code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>：在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>：尝试用<code>.bash_history</code>里面以前执行命令，进行补全。</li>
</ul>
<p>上面的<code>Alt</code>键也可以用 ESC 键代替。</p>
<h2 id="_49">操作历史</h2>
<h3 id="_50">基本用法</h3>
<p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入<code>~/.bash_history</code>文件，该文件默认储存500个操作。</p>
<p>环境变量<code>HISTFILE</code>总是指向这个文件。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$HISTFILE</span>
/home/me/.bash_history
</code></pre></div>

<p>有了操作历史以后，就可以使用方向键的<code>↑</code>和<code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> Hello World
Hello World

$ <span class="nb">echo</span> Goodbye
Goodbye

$ !e
<span class="nb">echo</span> Goodbye
Goodbye
</code></pre></div>

<p>上面例子中，<code>!e</code>表示找出操作历史之中，最近的那一条以<code>e</code>开头的命令并执行。Bash 会先输出那一条命令<code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code>也会执行最近一条以<code>echo</code>开头的命令。</p>
<div class="highlight"><pre><span></span><code>$ !echo
<span class="nb">echo</span> Goodbye
Goodbye

$ !echo H
<span class="nb">echo</span> Goodbye H
Goodbye H

$ !echo H G
<span class="nb">echo</span> Goodbye H G
Goodbye H G
</code></pre></div>

<p>注意，<code>!string</code>语法只会匹配命令，不会匹配参数。所以<code>!echo H</code>不会执行<code>echo Hello World</code>，而是会执行<code>echo Goobye</code>，并把参数<code>H</code>附加在这条命令之后。同理，<code>!echo H G</code>也是等同于<code>echo Goodbye</code>命令之后附件<code>H G</code>。</p>
<p>最后，按下<code>Ctrl + r</code>会显示操作历史，可以用方向键上下移动，选择其中要执行的命令。也可以键入命令的首字母，Shell 就会自动在历史文件中，查询并显示匹配的结果。</p>
<h3 id="history">history 命令</h3>
<p><code>history</code>命令能显示操作历史，即<code>.bash_history</code>文件的内容。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">history</span>
...
<span class="m">498</span> <span class="nb">echo</span> Goodbye
<span class="m">499</span> ls ~
<span class="m">500</span> <span class="nb">cd</span>
</code></pre></div>

<p>使用该命令，而不是直接读取<code>.bash_history</code>文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量<code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">export</span> <span class="nv">HISTTIMEFORMAT</span><span class="o">=</span><span class="s1">&#39;%F %T  &#39;</span>
$ <span class="nb">history</span>
<span class="m">1</span>  <span class="m">2013</span>-06-09 <span class="m">10</span>:40:12   cat /etc/issue
<span class="m">2</span>  <span class="m">2013</span>-06-09 <span class="m">10</span>:40:12   clear
</code></pre></div>

<p>上面代码中，<code>%F</code>相当于<code>%Y - %m - %d</code>，<code>%T</code>相当于<code>%H : %M : %S</code>。</p>
<p>只要设置<code>HISTTIMEFORMAT</code>这个环境变量，就会在<code>.bash_history</code>文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>如果不希望保存本次操作的历史，可以设置环境变量<code>HISTSIZE</code>等于0。</p>
<div class="highlight"><pre><span></span><code><span class="nb">export</span> <span class="nv">HISTSIZE</span><span class="o">=</span><span class="m">0</span>
</code></pre></div>

<p>如果<code>HISTSIZE=0</code>写入用户主目录的<code>~/.bashrc</code>文件，那么就不会保留该用户的操作历史。如果写入<code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合<code>grep</code>命令搜索操作历史。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">history</span> <span class="p">|</span> grep /usr/bin
</code></pre></div>

<p>上面命令返回<code>.bash_history</code>文件里面，那些包含<code>/usr/bin</code>的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用<code>感叹号 + 编号</code>执行该命令。如果想要执行<code>.bash_history</code>里面的第8条命令，可以像下面这样操作。</p>
<div class="highlight"><pre><span></span><code>$ !8
</code></pre></div>

<p><code>history</code>命令的<code>-c</code>参数可以清除操作历史。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">history</span> -c
</code></pre></div>

<h3 id="_51">相关快捷键</h3>
<p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>：显示上一个命令，与向上箭头效果相同（previous）。</li>
<li><code>Ctrl + n</code>：显示下一个命令，与向下箭头效果相同（next）。</li>
<li><code>Alt + &lt;</code>：显示第一个命令。</li>
<li><code>Alt + &gt;</code>：显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>：执行上一个命令。</li>
<li><code>!n</code>：执行历史文件里面行号为<code>n</code>的命令。</li>
<li><code>!-n</code>：执行当前命令之前<code>n</code>条的命令。</li>
<li><code>!string</code>：执行最近一个以指定字符串<code>string</code>开头的命令。</li>
<li><code>!?string</code>：执行最近一条包含字符串<code>string</code>的命令。</li>
<li><code>^string1^string2</code>：执行最近一条包含<code>string1</code>的命令，将其替换成<code>string2</code>。</li>
</ul>
<h2 id="_52">其他快捷键</h2>
<ul>
<li><code>Ctrl + j</code>：等同于回车键（LINEFEED）。</li>
<li><code>Ctrl + m</code>：等同于回车键（CARRIAGE RETURN）。</li>
<li><code>Ctrl + o</code>：等同于回车键，并展示操作历史的下一个命令。 </li>
<li><code>Ctrl + v</code>：将下一个输入的特殊字符变成字面量，比如回车变成<code>^M</code>。</li>
<li><code>Ctrl + [</code>：等同于 ESC。 </li>
<li><code>Alt + .</code>：插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>：等同于<code>Alt + .</code>。</li>
</ul>
<p>上面的<code>Alt + .</code>快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<div class="highlight"><pre><span></span><code>$ mkdir foo_bar
$ <span class="nb">cd</span> <span class="c1">#按下 Alt + .</span>
</code></pre></div>

<p>上面例子中，在<code>cd</code>命令后按下<code>Alt + .</code>，就会自动插入<code>foo_bar</code>。</p>
<h1 id="_53">目录堆栈</h1>
<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>
<h2 id="cd-">cd -</h2>
<p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code>命令可以返回前一次的目录。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 当前目录是 /path/to/foo</span>
$ <span class="nb">cd</span> bar

<span class="c1"># 重新回到 /path/to/foo</span>
$ <span class="nb">cd</span> -
</code></pre></div>

<p>上面例子中，用户原来所在的目录是<code>/path/to/foo</code>，进入子目录<code>bar</code>以后，使用<code>cd -</code>可以回到原来的目录。</p>
<h2 id="pushdpopd">pushd，popd</h2>
<p>如果希望记忆多重目录，可以使用<code>pushd</code>命令和<code>popd</code>命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code>命令的用法类似<code>cd</code>命令，可以进入指定的目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">pushd</span> dirname
</code></pre></div>

<p>上面命令会进入目录<code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用<code>pushd</code>命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用<code>pushd</code>命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code>命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 当前处在主目录，堆栈为空</span>
$ <span class="nb">pwd</span>
/home/me

<span class="c1"># 进入 /home/me/foo</span>
<span class="c1"># 当前堆栈为 /home/me/foo /home/me</span>
$ <span class="nb">pushd</span> ~/foo

<span class="c1"># 进入 /etc</span>
<span class="c1"># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span class="nb">pushd</span> /etc

<span class="c1"># 进入 /home/me/foo</span>
<span class="c1"># 当前堆栈为 /home/me/foo /home/me</span>
$ <span class="nb">popd</span>

<span class="c1"># 进入 /home/me</span>
<span class="c1"># 当前堆栈为 /home/me</span>
$ <span class="nb">popd</span>

<span class="c1"># 目录不变，当前堆栈为空</span>
$ <span class="nb">popd</span>
</code></pre></div>

<p>这两个命令的参数如下。</p>
<p><strong>（1）-n 参数</strong></p>
<p><code>-n</code>的参数表示仅操作堆栈，不改变目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">popd</span> -n
</code></pre></div>

<p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
<p><strong>（2）整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录（从0开始），作为操作对象。这时不会切换目录。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 从栈顶算起的3号目录（从0开始），移动到栈顶</span>
$ <span class="nb">pushd</span> +3

<span class="c1"># 从栈底算起的3号目录（从0开始），移动到栈顶</span>
$ <span class="nb">pushd</span> -3

<span class="c1"># 删除从栈顶算起的3号目录（从0开始）</span>
$ <span class="nb">popd</span> +3

<span class="c1"># 删除从栈底算起的3号目录（从0开始）</span>
$ <span class="nb">popd</span> -3
</code></pre></div>

<p>上面例子的整数编号都是从0开始计算，<code>popd +0</code>是删除第一个目录，<code>popd +1</code>是删除第二个，<code>popd -0</code>是删除最后一个目录，，<code>popd -1</code>是删除倒数第二个。</p>
<p><strong>（3）目录参数</strong></p>
<p><code>pushd</code>可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">pushd</span> dir
</code></pre></div>

<p><code>popd</code>没有这个参数。</p>
<h2 id="dirs">dirs 命令</h2>
<p><code>dirs</code>命令可以显示目录堆栈的内容，一般用来查看<code>pushd</code>和<code>popd</code>操作后的结果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">dirs</span>
</code></pre></div>

<p>它有以下参数。</p>
<ul>
<li><code>-c</code>：清空目录栈。</li>
<li><code>-l</code>：用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>：每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>：每行一个条目，每个条目之前显示位置编号（从0开始）。</li>
<li><code>+N</code>：<code>N</code>为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>：<code>N</code>为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
<h1 id="bash_6">Bash 脚本入门</h1>
<p>脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>
<h2 id="shebang">Shebang 行</h2>
<p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以<code>#!</code>字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code>后面就是脚本解释器的位置，Bash 脚本的解释器一般是<code>/bin/sh</code>或<code>/bin/bash</code>。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/sh</span>
<span class="c1"># 或者</span>
<span class="c1">#!/bin/bash</span>
</code></pre></div>

<p><code>#!</code>与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录<code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>
</code></pre></div>

<p>上面命令使用<code>env</code>命令（这个命令总是在<code>/usr/bin</code>目录），返回 Bash 可执行文件的位置。<code>env</code>命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是<code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<div class="highlight"><pre><span></span><code>$ ./script.sh
</code></pre></div>

<p>上面例子中，<code>script.sh</code>是脚本文件名。脚本通常使用<code>.sh</code>后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<div class="highlight"><pre><span></span><code>$ /bin/sh ./script.sh
<span class="c1"># 或者</span>
$ bash ./script.sh
</code></pre></div>

<h2 id="_54">执行权限和路径</h2>
<p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 给所有用户执行权限</span>
$ chmod +x script.sh

<span class="c1"># 给所有用户读权限和执行权限</span>
$ chmod +rx script.sh
<span class="c1"># 或者</span>
$ chmod <span class="m">755</span> script.sh

<span class="c1"># 只给脚本拥有者读权限和执行权限</span>
$ chmod u+rx script.sh
</code></pre></div>

<p>脚本的权限通常设为<code>755</code>（拥有者有所有权限，其他人有读和执行权限）或者<code>700</code>（只有拥有者可以执行）。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径（比如<code>path/script.sh</code>）。如果将脚本放在环境变量<code>$PATH</code>指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个<code>~/bin</code>子目录，专门存放可执行脚本，然后把<code>~/bin</code>加入<code>$PATH</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:~/bin
</code></pre></div>

<p>上面命令改变环境变量<code>$PATH</code>，将<code>~/bin</code>添加到<code>$PATH</code>的末尾。可以将这一行加到<code>~/.bashrc</code>文件里面，然后重新加载一次<code>.bashrc</code>，这个配置就可以生效了。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">source</span> ~/.bashrc
</code></pre></div>

<p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<div class="highlight"><pre><span></span><code>$ script.sh
</code></pre></div>

<p>上面命令没有指定脚本路径，因为<code>script.sh</code>在<code>$PATH</code>指定的目录中。</p>
<h2 id="env">env 命令</h2>
<p><code>env</code>命令总是指向<code>/usr/bin/env</code>文件，或者说，这个二进制文件总是在目录<code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code>这个语法的意思是，让 Shell 查找<code>$PATH</code>环境变量里面第一个匹配的<code>NAME</code>。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code>的意思就是，返回<code>bash</code>可执行文件的位置，前提是<code>bash</code>的路径是在<code>$PATH</code>里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env node</span>
</code></pre></div>

<p><code>env</code>命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>：不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>：从环境变量中删除一个变量。</li>
<li><code>--help</code>：显示帮助。</li>
<li><code>--version</code>：输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<div class="highlight"><pre><span></span><code>$ env -i /bin/sh
</code></pre></div>

<h2 id="_55">注释</h2>
<p>Bash 脚本中，<code>#</code>表示注释，可以放在行首，也可以放在行尾。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 本行是注释</span>
<span class="nb">echo</span> <span class="s1">&#39;Hello World!&#39;</span>

<span class="nb">echo</span> <span class="s1">&#39;Hello World!&#39;</span> <span class="c1"># 井号后面的部分也是注释</span>
</code></pre></div>

<p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="_56">脚本参数</h2>
<p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<div class="highlight"><pre><span></span><code>$ script.sh word1 word2 word3
</code></pre></div>

<p>上面例子中，<code>script.sh</code>是一个脚本文件，<code>word1</code>、<code>word2</code>和<code>word3</code>是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>：脚本文件名，即<code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>：对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>：参数的总数。</li>
<li><code>$@</code>：全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>：全部的参数，参数之间使用变量<code>$IFS</code>值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于9个，那么第10个参数可以用<code>${10}</code>的形式引用，以此类推。</p>
<p>注意，如果命令是<code>command -o foo bar</code>，那么<code>-o</code>是<code>$1</code>，<code>foo</code>是<code>$2</code>，<code>bar</code>是<code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># script.sh</span>

<span class="nb">echo</span> <span class="s2">&quot;全部参数：&quot;</span> <span class="nv">$@</span>
<span class="nb">echo</span> <span class="s2">&quot;命令行参数数量：&quot;</span> <span class="nv">$#</span>
<span class="nb">echo</span> <span class="s1">&#39;$0 = &#39;</span> <span class="nv">$0</span>
<span class="nb">echo</span> <span class="s1">&#39;$1 = &#39;</span> <span class="nv">$1</span>
<span class="nb">echo</span> <span class="s1">&#39;$2 = &#39;</span> <span class="nv">$2</span>
<span class="nb">echo</span> <span class="s1">&#39;$3 = &#39;</span> <span class="nv">$3</span>
</code></pre></div>

<p>执行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ ./script.sh a b c
全部参数：a b c
命令行参数数量：3
<span class="nv">$0</span> <span class="o">=</span>  script.sh
<span class="nv">$1</span> <span class="o">=</span>  a
<span class="nv">$2</span> <span class="o">=</span>  b
<span class="nv">$3</span> <span class="o">=</span>  c
</code></pre></div>

<p>用户可以输入任意数量的参数，利用<code>for</code>循环，可以读取每一个参数。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="k">for</span> i in <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，<code>$@</code>返回一个全部参数的列表，然后使用<code>for</code>循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<div class="highlight"><pre><span></span><code>$ ./script.sh <span class="s2">&quot;a b&quot;</span>
</code></pre></div>

<p>上面例子中，Bash 会认为<code>"a b"</code>是一个参数，<code>$1</code>会返回<code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift">shift 命令</h2>
<p><code>shift</code>命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（<code>$1</code>），使得后面的参数向前一位，即<code>$2</code>变成<code>$1</code>、<code>$3</code>变成<code>$2</code>、<code>$4</code>变成<code>$3</code>，以此类推。</p>
<p><code>while</code>循环结合<code>shift</code>命令，也可以读取每一个参数。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">&quot;一共输入了 </span><span class="nv">$#</span><span class="s2"> 个参数&quot;</span>

<span class="k">while</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;剩下 </span><span class="nv">$#</span><span class="s2"> 个参数&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;参数：</span><span class="nv">$1</span><span class="s2">&quot;</span>
  <span class="nb">shift</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，<code>shift</code>命令每次移除当前第一个参数，从而通过<code>while</code>循环遍历所有参数。</p>
<p><code>shift</code>命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为<code>1</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nb">shift</span> <span class="m">3</span>
</code></pre></div>

<p>上面的命令移除前三个参数，原来的<code>$4</code>变成<code>$1</code>。</p>
<h2 id="getopts">getopts 命令</h2>
<p><code>getopts</code>命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与<code>while</code>循环一起使用，取出脚本所有的带有前置连词线（<code>-</code>）的参数。</p>
<div class="highlight"><pre><span></span><code><span class="nb">getopts</span> optstring name
</code></pre></div>

<p>它带有两个参数。第一个参数<code>optstring</code>是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数<code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有<code>-a</code>可以带有参数值，而<code>-l</code>和<code>-h</code>是开关参数，那么<code>getopts</code>的第一个参数写成<code>lha:</code>，顺序不重要。注意，<code>a</code>后面有一个冒号，表示该参数带有参数值，<code>getopts</code>规定带有参数值的配置项参数，后面必须带有一个冒号（<code>:</code>）。<code>getopts</code>的第二个参数<code>name</code>是一个变量名，用来保存当前取到的配置项参数，即<code>l</code>、<code>h</code>或<code>a</code>。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span> <span class="nb">getopts</span> <span class="s1">&#39;lha:&#39;</span> OPTION<span class="p">;</span> <span class="k">do</span>
  <span class="k">case</span> <span class="s2">&quot;</span><span class="nv">$OPTION</span><span class="s2">&quot;</span> in
    l<span class="o">)</span>
      <span class="nb">echo</span> <span class="s2">&quot;linuxconfig&quot;</span>
      <span class="p">;;</span>

    h<span class="o">)</span>
      <span class="nb">echo</span> <span class="s2">&quot;h stands for h&quot;</span>
      <span class="p">;;</span>

    a<span class="o">)</span>
      <span class="nv">avalue</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$OPTARG</span><span class="s2">&quot;</span>
      <span class="nb">echo</span> <span class="s2">&quot;The value provided is </span><span class="nv">$OPTARG</span><span class="s2">&quot;</span>
      <span class="p">;;</span>
    ?<span class="o">)</span>
      <span class="nb">echo</span> <span class="s2">&quot;script usage: </span><span class="k">$(</span>basename <span class="nv">$0</span><span class="k">)</span><span class="s2"> [-l] [-h] [-a somevalue]&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
      <span class="nb">exit</span> <span class="m">1</span>
      <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
<span class="nb">shift</span> <span class="s2">&quot;</span><span class="k">$((</span><span class="nv">$OPTIND</span> <span class="o">-</span> <span class="m">1</span><span class="k">))</span><span class="s2">&quot;</span>
</code></pre></div>

<p>上面例子中，<code>while</code>循环不断执行<code>getopts 'lha:' OPTION</code>命令，每次执行就会读取一个连词线参数（以及对应的参数值），然后进入循环体。变量<code>OPTION</code>保存的是，当前处理的那一个连词线参数（即<code>l</code>、<code>h</code>或<code>a</code>）。如果用户输入了没有指定的参数（比如<code>-x</code>），那么<code>OPTION</code>等于<code>?</code>。循环体内使用<code>case</code>判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如<code>-a foo</code>，那么处理<code>a</code>参数的时候，环境变量<code>$OPTARG</code>保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code>就会执行失败，从而退出<code>while</code>循环。比如，<code>getopts</code>可以解析<code>command -l foo</code>，但不可以解析<code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如<code>command -lh</code>，<code>getopts</code>也可以正确处理。</p>
<p>变量<code>$OPTIND</code>在<code>getopts</code>开始执行前是<code>1</code>，然后每次执行就会加<code>1</code>。等到退出<code>while</code>循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code>就是已经处理的连词线参数个数，使用<code>shift</code>命令将这些参数移除，保证后面的代码可以用<code>$1</code>、<code>$2</code>等处理命令的主参数。</p>
<h2 id="-">配置项参数终止符 <code>--</code></h2>
<p>变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符<code>--</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">myPath</span><span class="o">=</span><span class="s2">&quot;~/docs&quot;</span>
$ ls -- <span class="nv">$myPath</span>
</code></pre></div>

<p>上面例子中，<code>--</code>强制变量<code>$myPath</code>只能当作实体参数（即路径名）解释。</p>
<p>如果变量不是路径名，就会报错。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">myPath</span><span class="o">=</span><span class="s2">&quot;-l&quot;</span>
$ ls -- <span class="nv">$myPath</span>
ls: 无法访问<span class="s1">&#39;-l&#39;</span>: 没有那个文件或目录
</code></pre></div>

<p>上面例子中，变量<code>myPath</code>的值为<code>-l</code>，不是路径。但是，<code>--</code>强制<code>$myPath</code>只能作为路径解释，导致报错“不存在该路径”。</p>
<h2 id="alias">别名，alias 命令</h2>
<p><code>alias</code>命令用来为一个命令指定别名，这样更便于记忆。下面是<code>alias</code>的格式。</p>
<div class="highlight"><pre><span></span><code><span class="nb">alias</span> <span class="nv">NAME</span><span class="o">=</span>DEFINITION
</code></pre></div>

<p>上面命令中，<code>NAME</code>是别名的名称，<code>DEFINITION</code>是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为<code>grep</code>命令起一个<code>search</code>的别名。</p>
<div class="highlight"><pre><span></span><code><span class="nb">alias</span> <span class="nv">search</span><span class="o">=</span>grep
</code></pre></div>

<p><code>alias</code>也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个<code>today</code>的命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">alias</span> <span class="nv">today</span><span class="o">=</span><span class="s1">&#39;date +&quot;%A, %B %-d, %Y&quot;&#39;</span>
$ today
星期一, 一月 <span class="m">6</span>, <span class="m">2020</span>
</code></pre></div>

<p>有时为了防止误删除文件，可以指定<code>rm</code>命令的别名。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">alias</span> <span class="nv">rm</span><span class="o">=</span><span class="s1">&#39;rm -i&#39;</span>
</code></pre></div>

<p>上面命令指定<code>rm</code>命令是<code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code>定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">alias</span> <span class="nv">echo</span><span class="o">=</span><span class="s1">&#39;echo It says: &#39;</span>
$ <span class="nb">echo</span> hello world
It says: hello world
</code></pre></div>

<p>上面例子中，别名定义了<code>echo</code>命令的前两个参数，等同于修改了<code>echo</code>命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在<code>~/.bashrc</code>的末尾。另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的。</p>
<p>直接调用<code>alias</code>命令，可以显示所有别名。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">alias</span>
</code></pre></div>

<p><code>unalias</code>命令可以解除别名。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">unalias</span> lt
</code></pre></div>

<h2 id="exit">exit 命令</h2>
<p><code>exit</code>命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">exit</span>
</code></pre></div>

<p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code>命令后面可以跟参数，该参数就是退出状态。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 退出值为0（成功）</span>
$ <span class="nb">exit</span> <span class="m">0</span>

<span class="c1"># 退出值为1（失败）</span>
$ <span class="nb">exit</span> <span class="m">1</span>
</code></pre></div>

<p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code>表示正常，<code>1</code>表示发生错误，<code>2</code>表示用法不对，<code>126</code>表示不是可执行脚本，<code>127</code>表示命令没有发现。如果脚本被信号<code>N</code>终止，则退出值为<code>128 + N</code>。简单来说，只要退出值非0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="o">[</span> <span class="k">$(</span>id -u<span class="k">)</span> !<span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;根用户才能执行当前脚本&quot;</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面的例子中，<code>id -u</code>命令返回用户的 ID，一旦用户的 ID 不等于<code>0</code>（根用户的 ID），脚本就会退出，并且退出码为<code>1</code>，表示运行失败。</p>
<p><code>exit</code>与<code>return</code>命令的差别是，<code>return</code>命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code>是整个脚本的退出，如果在函数之中调用<code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="_57">命令执行结果</h2>
<p>命令执行结束后，会有一个返回值。<code>0</code>表示执行成功，非<code>0</code>（通常是<code>1</code>）表示执行失败。环境变量<code>$?</code>可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<div class="highlight"><pre><span></span><code><span class="nb">cd</span> <span class="nv">$some_directory</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  rm *
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;无法切换目录！&quot;</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，<code>cd $some_directory</code>这个命令如果执行成功（返回值等于<code>0</code>），就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为<code>1</code>，表示执行失败。</p>
<p>由于<code>if</code>可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="nb">cd</span> <span class="nv">$some_directory</span><span class="p">;</span> <span class="k">then</span>
  rm *
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Could not change directory! Aborting.&quot;</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>更简洁的写法是利用两个逻辑运算符<code>&amp;&amp;</code>（且）和<code>||</code>（或）。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 第一步执行成功，才会执行第二步</span>
<span class="nb">cd</span> <span class="nv">$some_directory</span> <span class="o">&amp;&amp;</span> rm *

<span class="c1"># 第一步执行失败，才会执行第二步</span>
<span class="nb">cd</span> <span class="nv">$some_directory</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
</code></pre></div>

<h2 id="_58">参考链接</h2>
<ul>
<li><a href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options">How to use getopts to parse a script options</a>, Egidio Docile</li>
</ul>
<h1 id="read">read 命令</h1>
<h2 id="_59">用法</h2>
<p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用<code>read</code>命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code>命令的格式如下。</p>
<div class="highlight"><pre><span></span><code><span class="nb">read</span> <span class="o">[</span>-options<span class="o">]</span> <span class="o">[</span>variable...<span class="o">]</span>
</code></pre></div>

<p>上面语法中，<code>options</code>是参数选项，<code>variable</code>是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量<code>REPLY</code>会包含用户输入的一整行数据。</p>
<p>下面是一个例子<code>demo.sh</code>。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> -n <span class="s2">&quot;输入一些文本 &gt; &quot;</span>
<span class="nb">read</span> text
<span class="nb">echo</span> <span class="s2">&quot;你的输入：</span><span class="nv">$text</span><span class="s2">&quot;</span>
</code></pre></div>

<p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量<code>text</code>，在下一行显示出来。</p>
<div class="highlight"><pre><span></span><code>$ bash demo.sh
输入一些文本 &gt; 你好，世界
你的输入：你好，世界
</code></pre></div>

<p><code>read</code>可以接受用户输入的多个值。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="nb">echo</span> Please, enter your firstname and lastname
<span class="nb">read</span> FN LN
<span class="nb">echo</span> <span class="s2">&quot;Hi! </span><span class="nv">$LN</span><span class="s2">, </span><span class="nv">$FN</span><span class="s2"> !&quot;</span>
</code></pre></div>

<p>上面例子中，<code>read</code>根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于<code>read</code>命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果<code>read</code>命令之后没有定义变量名，那么环境变量<code>REPLY</code>会包含所有的输入。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># read-single: read multiple values into default variable</span>
<span class="nb">echo</span> -n <span class="s2">&quot;Enter one or more values &gt; &quot;</span>
<span class="nb">read</span>
<span class="nb">echo</span> <span class="s2">&quot;REPLY = &#39;</span><span class="nv">$REPLY</span><span class="s2">&#39;&quot;</span>
</code></pre></div>

<p>上面脚本的运行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ read-single
Enter one or more values &gt; a b c d
<span class="nv">REPLY</span> <span class="o">=</span> <span class="s1">&#39;a b c d&#39;</span>
</code></pre></div>

<p><code>read</code>命令除了读取键盘输入，可以用来读取文件。</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span> <span class="nb">read</span> myline
<span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$myline</span><span class="s2">&quot;</span>
<span class="k">done</span> &lt; <span class="nv">$filename</span>
</code></pre></div>

<p>上面的例子通过<code>read</code>命令，读取一个文件的内容。<code>done</code>命令后面的定向符<code>&lt;</code>，将文件导向<code>read</code>命令，每次读取一行，存入变量<code>myline</code>，直到文件读取完毕。</p>
<h2 id="_60">参数</h2>
<p><code>read</code>命令的参数如下。</p>
<p><strong>（1）-t 参数</strong></p>
<p><code>read</code>命令的<code>-t</code>参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> -n <span class="s2">&quot;输入一些文本 &gt; &quot;</span>
<span class="k">if</span> <span class="nb">read</span> -t <span class="m">3</span> response<span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;用户已经输入了&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;用户没有输入&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，输入命令会等待3秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code>根据命令的返回值，转入<code>else</code>代码块，继续往下执行。</p>
<p>环境变量<code>TMOUT</code>也可以起到同样作用，指定<code>read</code>命令等待用户输入的时间（单位为秒）。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">TMOUT</span><span class="o">=</span><span class="m">3</span>
$ <span class="nb">read</span> response
</code></pre></div>

<p>上面例子也是等待3秒，如果用户还没有输入，就会超时。</p>
<p><strong>（2）-p 参数</strong></p>
<p><code>-p</code>参数指定用户输入的提示信息。</p>
<div class="highlight"><pre><span></span><code><span class="nb">read</span> -p <span class="s2">&quot;Enter one or more values &gt; &quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;REPLY = &#39;</span><span class="nv">$REPLY</span><span class="s2">&#39;&quot;</span>
</code></pre></div>

<p>上面例子中，先显示<code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
<p><strong>（3）-a 参数</strong></p>
<p><code>-a</code>参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">read</span> -a people
alice duchess dodo
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">people</span><span class="p">[2]</span><span class="si">}</span>
dodo
</code></pre></div>

<p>上面例子中，用户输入被赋值给一个数组<code>people</code>，这个数组的2号成员就是<code>dodo</code>。</p>
<p><strong>（4）-n 参数</strong></p>
<p><code>-n</code>参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">read</span> -n <span class="m">3</span> letter
abcdefghij
$ <span class="nb">echo</span> <span class="nv">$letter</span>
abc
</code></pre></div>

<p>上面例子中，变量<code>letter</code>只包含3个字母。</p>
<p><strong>（5）-e 参数</strong></p>
<p><code>-e</code>参数允许用户输入的时候，使用<code>readline</code>库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> Please input the path to the file:

<span class="nb">read</span> -e fileName

<span class="nb">echo</span> <span class="nv">$fileName</span>
</code></pre></div>

<p>上面例子中，<code>read</code>命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是<code>read</code>命令的输入默认不支持<code>readline</code>库的功能。<code>-e</code>参数就可以允许用户使用自动补全。</p>
<p><strong>（6）其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>：定义字符串<code>delimiter</code>的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>：raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>：使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>：使用文件描述符<code>fd</code>作为输入。</li>
</ul>
<h2 id="ifs">IFS 变量</h2>
<p><code>read</code>命令读取的值，默认是以空格分隔。可以通过自定义环境变量<code>IFS</code>（内部字段分隔符，Internal Field Separator 的缩写），修改分隔标志。</p>
<p><code>IFS</code>的默认值是空格、Tab 符号、换行符号，通常取第一个（即空格）。</p>
<p>如果把<code>IFS</code>定义成冒号（<code>:</code>）或分号（<code>;</code>），就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># read-ifs: read fields from a file</span>

<span class="nv">FILE</span><span class="o">=</span>/etc/passwd

<span class="nb">read</span> -p <span class="s2">&quot;Enter a username &gt; &quot;</span> user_name
<span class="nv">file_info</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>grep <span class="s2">&quot;^</span><span class="nv">$user_name</span><span class="s2">:&quot;</span> <span class="nv">$FILE</span><span class="k">)</span><span class="s2">&quot;</span>

<span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;</span><span class="nv">$file_info</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nv">IFS</span><span class="o">=</span><span class="s2">&quot;:&quot;</span> <span class="nb">read</span> user pw uid gid name home shell <span class="o">&lt;&lt;&lt;</span> <span class="s2">&quot;</span><span class="nv">$file_info</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;User = &#39;</span><span class="nv">$user</span><span class="s2">&#39;&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;UID = &#39;</span><span class="nv">$uid</span><span class="s2">&#39;&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;GID = &#39;</span><span class="nv">$gid</span><span class="s2">&#39;&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;Full Name = &#39;</span><span class="nv">$name</span><span class="s2">&#39;&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;Home Dir. = &#39;</span><span class="nv">$home</span><span class="s2">&#39;&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;Shell = &#39;</span><span class="nv">$shell</span><span class="s2">&#39;&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;No such user &#39;</span><span class="nv">$user_name</span><span class="s2">&#39;&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，<code>IFS</code>设为冒号，然后用来分解<code>/etc/passwd</code>文件的一行。<code>IFS</code>的赋值命令和<code>read</code>命令写在一行，这样的话，<code>IFS</code>的改变仅对后面的命令生效，该命令执行后<code>IFS</code>会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<div class="highlight"><pre><span></span><code><span class="nv">OLD_IFS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$IFS</span><span class="s2">&quot;</span>
<span class="nv">IFS</span><span class="o">=</span><span class="s2">&quot;:&quot;</span>
<span class="nb">read</span> user pw uid gid name home shell <span class="o">&lt;&lt;&lt;</span> <span class="s2">&quot;</span><span class="nv">$file_info</span><span class="s2">&quot;</span>
<span class="nv">IFS</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$OLD_IFS</span><span class="s2">&quot;</span>
</code></pre></div>

<p>另外，上面例子中，<code>&lt;&lt;&lt;</code>是 Here 字符串，用于将变量值转为标准输入，因为<code>read</code>命令只能解析标准输入。</p>
<p>如果<code>IFS</code>设为空字符串，就等同于将整行读入一个变量。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="nv">input</span><span class="o">=</span><span class="s2">&quot;/path/to/txt/file&quot;</span>
<span class="k">while</span> <span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> -r line
<span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$line</span><span class="s2">&quot;</span>
<span class="k">done</span> &lt; <span class="s2">&quot;</span><span class="nv">$input</span><span class="s2">&quot;</span>
</code></pre></div>

<p>上面的命令可以逐行读取文件，每一行存入变量<code>line</code>，打印出来以后再读取下一行。</p>
<h1 id="_61">条件判断</h1>
<p>本章介绍 Bash 脚本的条件判断语法。</p>
<h2 id="if">if 结构</h2>
<p><code>if</code>是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> commands<span class="p">;</span> <span class="k">then</span>
  commands
<span class="o">[</span><span class="k">elif</span> commands<span class="p">;</span> <span class="k">then</span>
  commands...<span class="o">]</span>
<span class="o">[</span><span class="k">else</span>
  commands<span class="o">]</span>
<span class="k">fi</span>
</code></pre></div>

<p>这个命令分成三个部分：<code>if</code>、<code>elif</code>和<code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code>关键字后面是主要的判断条件，<code>elif</code>用来添加在主条件不成立时的其他判断条件，<code>else</code>则是所有条件都不成立时要执行的部分。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="nb">test</span> <span class="nv">$USER</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Hello foo.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;You are not foo.&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面的例子中，判断条件是环境变量<code>$USER</code>是否等于<code>foo</code>，如果等于就输出<code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code>和<code>then</code>写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="nb">true</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span>
<span class="k">fi</span>

<span class="k">if</span> <span class="nb">false</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s1">&#39;it is false&#39;</span> <span class="c1"># 本行不会执行</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面的例子中，<code>true</code>和<code>false</code>是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code>意味着命令部分总是会执行，<code>if false</code>意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code>结构也可以写成单行。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">if</span> true<span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span><span class="p">;</span> <span class="k">fi</span>
hello world

$ <span class="k">if</span> false<span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;It&#39;s true.&quot;</span><span class="p">;</span> <span class="k">fi</span>
</code></pre></div>

<p>注意，<code>if</code>关键字后面也可以是一条命令，该条命令执行成功（返回值<code>0</code>），就意味着判断条件成立。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">if</span> <span class="nb">echo</span> <span class="s1">&#39;hi&#39;</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span><span class="p">;</span> <span class="k">fi</span>
hi
hello world
</code></pre></div>

<p>上面命令中，<code>if</code>后面是一条命令<code>echo 'hi'</code>。该命令会执行，如果返回值是<code>0</code>，则执行<code>then</code>的部分。</p>
<p><code>if</code>后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回<code>0</code>，就会执行<code>then</code>的部分。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">if</span> false<span class="p">;</span> true<span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span><span class="p">;</span> <span class="k">fi</span>
hello world
</code></pre></div>

<p>上面例子中，<code>if</code>后面有两条命令（<code>false;true;</code>），第二条命令（<code>true</code>）决定了<code>then</code>的部分是否会执行。</p>
<p><code>elif</code>部分可以有多个。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> -n <span class="s2">&quot;输入一个1到3之间的数字（包含两端）&gt; &quot;</span>
<span class="nb">read</span> character
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$character</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="m">1</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$character</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;2&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="m">2</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$character</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;3&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="m">3</span>
<span class="k">else</span>
    <span class="nb">echo</span> 输入不符合要求
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，如果用户输入<code>3</code>，就会连续判断3次。</p>
<h2 id="test">test 命令</h2>
<p><code>if</code>结构的判断条件，一般使用<code>test</code>命令，有三种形式。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 写法一</span>
<span class="nb">test</span> expression

<span class="c1"># 写法二</span>
<span class="o">[</span> expression <span class="o">]</span>

<span class="c1"># 写法三</span>
<span class="o">[[</span> expression <span class="o">]]</span>
</code></pre></div>

<p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的<code>expression</code>是一个表达式。这个表达式为真，<code>test</code>命令执行成功（返回值为<code>0</code>）；表达式为伪，<code>test</code>命令执行失败（返回值为<code>1</code>）。注意，第二种和第三种写法，<code>[</code>和<code>]</code>与内部的表达式之间必须有空格。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">test</span> -f /etc/hosts
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>

$ <span class="o">[</span> -f /etc/hosts <span class="o">]</span>
$  <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>
</code></pre></div>

<p>上面的例子中，<code>test</code>命令采用两种写法，判断<code>/etc/hosts</code>文件是否存在，这两种写法是等价的。命令执行后，返回值为<code>0</code>，表示该文件确实存在。</p>
<p>下面把<code>test</code>命令的三种形式，用在<code>if</code>结构中，判断一个文件是否存在。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 写法一</span>
<span class="k">if</span> <span class="nb">test</span> -e /tmp/foo.txt <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Found foo.txt&quot;</span>
<span class="k">fi</span>

<span class="c1"># 写法二</span>
<span class="k">if</span> <span class="o">[</span> -e /tmp/foo.txt <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Found foo.txt&quot;</span>
<span class="k">fi</span>

<span class="c1"># 写法三</span>
<span class="k">if</span> <span class="o">[[</span> -e /tmp/foo.txt <span class="o">]]</span> <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Found foo.txt&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<h2 id="_62">判断表达式</h2>
<p><code>if</code>关键字后面，跟的是一个命令。这个命令可以是<code>test</code>命令，也可以是其他命令。命令的返回值为<code>0</code>表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="_63">文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>：如果 file 存在，则为<code>true</code>。</li>
<li><code>[ -b file ]</code>：如果 file 存在并且是一个块（设备）文件，则为<code>true</code>。</li>
<li><code>[ -c file ]</code>：如果 file 存在并且是一个字符（设备）文件，则为<code>true</code>。</li>
<li><code>[ -d file ]</code>：如果 file 存在并且是一个目录，则为<code>true</code>。</li>
<li><code>[ -e file ]</code>：如果 file 存在，则为<code>true</code>。</li>
<li><code>[ -f file ]</code>：如果 file 存在并且是一个普通文件，则为<code>true</code>。</li>
<li><code>[ -g file ]</code>：如果 file 存在并且设置了组 ID，则为<code>true</code>。</li>
<li><code>[ -G file ]</code>：如果 file 存在并且属于有效的组 ID，则为<code>true</code>。</li>
<li><code>[ -h file ]</code>：如果 file 存在并且是符号链接，则为<code>true</code>。</li>
<li><code>[ -k file ]</code>：如果 file 存在并且设置了它的“sticky bit”，则为<code>true</code>。</li>
<li><code>[ -L file ]</code>：如果 file 存在并且是一个符号链接，则为<code>true</code>。</li>
<li><code>[ -N file ]</code>：如果 file 存在并且自上次读取后已被修改，则为<code>true</code>。</li>
<li><code>[ -O file ]</code>：如果 file 存在并且属于有效的用户 ID，则为<code>true</code>。</li>
<li><code>[ -p file ]</code>：如果 file 存在并且是一个命名管道，则为<code>true</code>。</li>
<li><code>[ -r file ]</code>：如果 file 存在并且可读（当前用户有可读权限），则为<code>true</code>。</li>
<li><code>[ -s file ]</code>：如果 file 存在且其长度大于零，则为<code>true</code>。</li>
<li><code>[ -S file ]</code>：如果 file 存在且是一个网络 socket，则为<code>true</code>。</li>
<li><code>[ -t fd ]</code>：如果 fd 是一个文件描述符，并且重定向到终端，则为<code>true</code>。 这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>：如果 file 存在并且设置了 setuid 位，则为<code>true</code>。</li>
<li><code>[ -w file ]</code>：如果 file 存在并且可写（当前用户拥有可写权限），则为<code>true</code>。</li>
<li><code>[ -x file ]</code>：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为<code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为<code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为<code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为<code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">FILE</span><span class="o">=</span>~/.bashrc

<span class="k">if</span> <span class="o">[</span> -e <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="k">if</span> <span class="o">[</span> -f <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2"> is a regular file.&quot;</span>
  <span class="k">fi</span>
  <span class="k">if</span> <span class="o">[</span> -d <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2"> is a directory.&quot;</span>
  <span class="k">fi</span>
  <span class="k">if</span> <span class="o">[</span> -r <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2"> is readable.&quot;</span>
  <span class="k">fi</span>
  <span class="k">if</span> <span class="o">[</span> -w <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2"> is writable.&quot;</span>
  <span class="k">fi</span>
  <span class="k">if</span> <span class="o">[</span> -x <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2"> is executable/searchable.&quot;</span>
  <span class="k">fi</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$FILE</span><span class="s2"> does not exist&quot;</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面代码中，<code>$FILE</code>要放在双引号之中。这样可以防止<code>$FILE</code>为空，因为这时<code>[ -e ]</code>会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e "" ]</code>会判断为伪。</p>
<h3 id="_64">字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>：如果<code>string</code>不为空（长度大于0），则判断为真。</li>
<li><code>[ -n string ]</code>：如果字符串<code>string</code>的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>：如果字符串<code>string</code>的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>：如果<code>string1</code>和<code>string2</code>相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于<code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>：如果<code>string1</code>和<code>string2</code>不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>：如果按照字典顺序<code>string1</code>排列在<code>string2</code>之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>：如果按照字典顺序<code>string1</code>排列在<code>string2</code>之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code>命令内部的<code>&gt;</code>和<code>&lt;</code>，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">ANSWER</span><span class="o">=</span>maybe

<span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;</span><span class="nv">$ANSWER</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;There is no answer.&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$ANSWER</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;yes&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;The answer is YES.&quot;</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$ANSWER</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;no&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;The answer is NO.&quot;</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$ANSWER</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;maybe&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;The answer is MAYBE.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;The answer is UNKNOWN.&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面代码中，首先确定<code>$ANSWER</code>字符串是否为空。如果为空，就终止脚本，并把退出状态设为<code>1</code>。注意，这里的<code>echo</code>命令把错误信息<code>There is no answer.</code>重定向到标准错误，这是处理错误信息的常用方法。如果<code>$ANSWER</code>字符串不为空，就判断它的值是否等于<code>yes</code>、<code>no</code>或者<code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如<code>[ -n "$COUNT" ]</code>，否则变量替换成字符串以后，<code>test</code>命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成<code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n "" ]</code>就判断为伪。</p>
<h3 id="_65">整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>：如果<code>integer1</code>等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>：如果<code>integer1</code>不等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>：如果<code>integer1</code>小于或等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>：如果<code>integer1</code>小于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>：如果<code>integer1</code>大于或等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>：如果<code>integer1</code>大于<code>integer2</code>，则为<code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">INT</span><span class="o">=</span>-5

<span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;INT is empty.&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$INT</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;INT is zero.&quot;</span>
<span class="k">else</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$INT</span> -lt <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;INT is negative.&quot;</span>
  <span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;INT is positive.&quot;</span>
  <span class="k">fi</span>
  <span class="k">if</span> <span class="o">[</span> <span class="k">$((</span>INT <span class="o">%</span> <span class="m">2</span><span class="k">))</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;INT is even.&quot;</span>
  <span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;INT is odd.&quot;</span>
  <span class="k">fi</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，先判断变量<code>$INT</code>是否为空，然后判断是否为<code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="_66">正则判断</h3>
<p><code>[[ expression ]]</code>这种判断形式，支持正则表达式。</p>
<div class="highlight"><pre><span></span><code><span class="o">[[</span> <span class="nv">string1</span> <span class="o">=</span>~ regex <span class="o">]]</span>
</code></pre></div>

<p>上面的语法中，<code>regex</code>是一个正则表示式，<code>=~</code>是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">INT</span><span class="o">=</span>-5

<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2">&quot;</span> <span class="o">=</span>~ ^-?<span class="o">[</span><span class="m">0</span>-9<span class="o">]</span>+$ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;INT is an integer.&quot;</span>
  <span class="nb">exit</span> <span class="m">0</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;INT is not an integer.&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面代码中，先判断变量<code>INT</code>的字符串形式，是否满足<code>^-?[0-9]+$</code>的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test_1">test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个<code>test</code>判断表达式结合起来，创造更复杂的判断。三种逻辑运算<code>AND</code>，<code>OR</code>，和<code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code>运算：符号<code>&amp;&amp;</code>，也可使用参数<code>-a</code>。</li>
<li><code>OR</code>运算：符号<code>||</code>，也可使用参数<code>-o</code>。</li>
<li><code>NOT</code>运算：符号<code>!</code>。</li>
</ul>
<p>下面是一个<code>AND</code>的例子，判断整数是否在某个范围之内。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">MIN_VAL</span><span class="o">=</span><span class="m">1</span>
<span class="nv">MAX_VAL</span><span class="o">=</span><span class="m">100</span>

<span class="nv">INT</span><span class="o">=</span><span class="m">50</span>

<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2">&quot;</span> <span class="o">=</span>~ ^-?<span class="o">[</span><span class="m">0</span>-9<span class="o">]</span>+$ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nv">$INT</span> -ge <span class="nv">$MIN_VAL</span> <span class="o">&amp;&amp;</span> <span class="nv">$INT</span> -le <span class="nv">$MAX_VAL</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2"> is within </span><span class="nv">$MIN_VAL</span><span class="s2"> to </span><span class="nv">$MAX_VAL</span><span class="s2">.&quot;</span>
  <span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2"> is out of range.&quot;</span>
  <span class="k">fi</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;INT is not an integer.&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，<code>&amp;&amp;</code>用来连接两个判断条件：大于等于<code>$MIN_VAL</code>，并且小于等于<code>$MAX_VAL</code>。</p>
<p>使用否定操作符<code>!</code>时，最好用圆括号确定转义的范围。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="o">[</span> ! <span class="se">\(</span> <span class="nv">$INT</span> -ge <span class="nv">$MIN_VAL</span> -a <span class="nv">$INT</span> -le <span class="nv">$MAX_VAL</span> <span class="se">\)</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2"> is outside </span><span class="nv">$MIN_VAL</span><span class="s2"> to </span><span class="nv">$MAX_VAL</span><span class="s2">.&quot;</span>
<span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2"> is in range.&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面例子中，<code>test</code>命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="_67">算术判断</h3>
<p>Bash 还提供了<code>((...))</code>作为算术条件，进行算术运算的判断。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="o">((</span><span class="m">3</span> &gt; <span class="m">2</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;true&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面代码执行后，会打印出<code>true</code>。</p>
<p>注意，算术判断不需要使用<code>test</code>命令，而是直接使用<code>((...))</code>结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">if</span> <span class="o">((</span><span class="m">1</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;It is true.&quot;</span><span class="p">;</span> <span class="k">fi</span>
It is true.
$ <span class="k">if</span> <span class="o">((</span><span class="m">0</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;It is true.&quot;</span><span class="p">;</span> <span class="k">else</span> <span class="nb">echo</span> <span class="s2">&quot;it is false.&quot;</span><span class="p">;</span> <span class="k">fi</span>
It is false.
</code></pre></div>

<p>上面例子中，<code>((1))</code>表示判断成立，<code>((0))</code>表示判断不成立。</p>
<p>算术条件<code>((...))</code>也可以用于变量赋值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">if</span> <span class="o">((</span> <span class="nv">foo</span> <span class="o">=</span> <span class="m">5</span> <span class="o">))</span><span class="p">;</span><span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;foo is </span><span class="nv">$foo</span><span class="s2">&quot;</span><span class="p">;</span> <span class="k">fi</span>
foo is <span class="m">5</span>
</code></pre></div>

<p>上面例子中，<code>(( foo = 5 ))</code>完成了两件事情。首先把<code>5</code>赋值给变量<code>foo</code>，然后根据返回值<code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是<code>0</code>，则判断为假。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">if</span> <span class="o">((</span> <span class="nv">foo</span> <span class="o">=</span> <span class="m">0</span> <span class="o">))</span><span class="p">;</span><span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;It is true.&quot;</span><span class="p">;</span><span class="k">else</span> <span class="nb">echo</span> <span class="s2">&quot;It is false.&quot;</span><span class="p">;</span> <span class="k">fi</span>
It is false.
</code></pre></div>

<p>下面是用算术条件改写的数值判断脚本。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">INT</span><span class="o">=</span>-5

<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$INT</span><span class="s2">&quot;</span> <span class="o">=</span>~ ^-?<span class="o">[</span><span class="m">0</span>-9<span class="o">]</span>+$ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="k">if</span> <span class="o">((</span><span class="nv">INT</span> <span class="o">==</span> <span class="m">0</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;INT is zero.&quot;</span>
  <span class="k">else</span>
    <span class="k">if</span> <span class="o">((</span>INT &lt; <span class="m">0</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span>
      <span class="nb">echo</span> <span class="s2">&quot;INT is negative.&quot;</span>
    <span class="k">else</span>
      <span class="nb">echo</span> <span class="s2">&quot;INT is positive.&quot;</span>
    <span class="k">fi</span>
    <span class="k">if</span> <span class="o">((</span> <span class="o">((</span>INT % <span class="m">2</span><span class="o">))</span> <span class="o">==</span> <span class="m">0</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span>
      <span class="nb">echo</span> <span class="s2">&quot;INT is even.&quot;</span>
    <span class="k">else</span>
      <span class="nb">echo</span> <span class="s2">&quot;INT is odd.&quot;</span>
    <span class="k">fi</span>
  <span class="k">fi</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;INT is not an integer.&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<p>只要是算术表达式，都能用于<code>((...))</code>语法，详见《Bash 的算术运算》一章。</p>
<h3 id="_68">普通命令的逻辑运算</h3>
<p>如果<code>if</code>结构使用的不是<code>test</code>命令，而是普通命令，比如上一节的<code>((...))</code>算术运算，或者<code>test</code>命令与普通命令混用，那么可以使用 Bash 的命令控制操作符<code>&amp;&amp;</code>（AND）和<code>||</code>（OR），进行多个命令的逻辑运算。</p>
<div class="highlight"><pre><span></span><code>$ command1 <span class="o">&amp;&amp;</span> command2
$ command1 <span class="o">||</span> command2
</code></pre></div>

<p>对于<code>&amp;&amp;</code>操作符，先执行<code>command1</code>，只有<code>command1</code>执行成功后， 才会执行<code>command2</code>。对于<code>||</code>操作符，先执行<code>command1</code>，只有<code>command1</code>执行失败后， 才会执行<code>command2</code>。</p>
<div class="highlight"><pre><span></span><code>$ mkdir temp <span class="o">&amp;&amp;</span> <span class="nb">cd</span> temp
</code></pre></div>

<p>上面的命令会创建一个名为<code>temp</code>的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div class="highlight"><pre><span></span><code>$ <span class="o">[</span> -d temp <span class="o">]</span> <span class="o">||</span> mkdir temp
</code></pre></div>

<p>上面的命令会测试目录<code>temp</code>是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span> ! -d temp <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">exit</span> <span class="m">1</span>
</code></pre></div>

<p>上面的命令中，如果<code>temp</code>子目录不存在，脚本会终止，并且返回值为<code>1</code>。</p>
<p>下面就是<code>if</code>与<code>&amp;&amp;</code>结合使用的写法。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="o">[</span> condition <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> condition <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">command</span>
<span class="k">fi</span>
</code></pre></div>

<p>下面是一个示例。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#! /bin/bash</span>

<span class="nv">filename</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">word1</span><span class="o">=</span><span class="nv">$2</span>
<span class="nv">word2</span><span class="o">=</span><span class="nv">$3</span>

<span class="k">if</span> grep <span class="nv">$word1</span> <span class="nv">$filename</span> <span class="o">&amp;&amp;</span> grep <span class="nv">$word2</span> <span class="nv">$filename</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$word1</span><span class="s2"> and </span><span class="nv">$word2</span><span class="s2"> are both in </span><span class="nv">$filename</span><span class="s2">.&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面的例子只有在指定文件里面，同时存在搜索词<code>word1</code>和<code>word2</code>，就会执行<code>if</code>的命令部分。</p>
<p>下面的示例演示如何将一个<code>&amp;&amp;</code>判断表达式，改写成对应的<code>if</code>结构。</p>
<div class="highlight"><pre><span></span><code><span class="o">[[</span> -d <span class="s2">&quot;</span><span class="nv">$dir_name</span><span class="s2">&quot;</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="nv">$dir_name</span><span class="s2">&quot;</span> <span class="o">&amp;&amp;</span> rm *

<span class="c1"># 等同于</span>

<span class="k">if</span> <span class="o">[[</span> ! -d <span class="s2">&quot;</span><span class="nv">$dir_name</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;No such directory: &#39;</span><span class="nv">$dir_name</span><span class="s2">&#39;&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="k">if</span> ! <span class="nb">cd</span> <span class="s2">&quot;</span><span class="nv">$dir_name</span><span class="s2">&quot;</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Cannot cd to &#39;</span><span class="nv">$dir_name</span><span class="s2">&#39;&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="k">if</span> ! rm *<span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;File deletion failed. Check results&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></div>

<h2 id="case">case 结构</h2>
<p><code>case</code>结构用于多值判断，可以为每个值指定对应的命令，跟包含多个<code>elif</code>的<code>if</code>结构等价，但是语义更好。它的语法如下。</p>
<div class="highlight"><pre><span></span><code><span class="k">case</span> expression in
  pattern <span class="o">)</span>
    commands <span class="p">;;</span>
  pattern <span class="o">)</span>
    commands <span class="p">;;</span>
  ...
<span class="k">esac</span>
</code></pre></div>

<p>上面代码中，<code>expression</code>是一个表达式，<code>pattern</code>是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号（<code>;</code>）结尾。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> -n <span class="s2">&quot;输入一个1到3之间的数字（包含两端）&gt; &quot;</span>
<span class="nb">read</span> character
<span class="k">case</span> <span class="nv">$character</span> in
  <span class="m">1</span> <span class="o">)</span> <span class="nb">echo</span> <span class="m">1</span>
    <span class="p">;;</span>
  <span class="m">2</span> <span class="o">)</span> <span class="nb">echo</span> <span class="m">2</span>
    <span class="p">;;</span>
  <span class="m">3</span> <span class="o">)</span> <span class="nb">echo</span> <span class="m">3</span>
    <span class="p">;;</span>
  * <span class="o">)</span> <span class="nb">echo</span> 输入不符合要求
<span class="k">esac</span>
</code></pre></div>

<p>上面例子中，最后一条匹配语句的模式是<code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似<code>if</code>的<code>else</code>部分。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">OS</span><span class="o">=</span><span class="k">$(</span>uname -s<span class="k">)</span>

<span class="k">case</span> <span class="s2">&quot;</span><span class="nv">$OS</span><span class="s2">&quot;</span> in
  FreeBSD<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;This is FreeBSD&quot;</span> <span class="p">;;</span>
  Darwin<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;This is Mac OSX&quot;</span> <span class="p">;;</span>
  AIX<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;This is AIX&quot;</span> <span class="p">;;</span>
  Minix<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;This is Minix&quot;</span> <span class="p">;;</span>
  Linux<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;This is Linux&quot;</span> <span class="p">;;</span>
  *<span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;Failed to identify this OS&quot;</span> <span class="p">;;</span>
<span class="k">esac</span>
</code></pre></div>

<p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code>的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>：匹配<code>a</code>。</li>
<li><code>a|b)</code>：匹配<code>a</code>或<code>b</code>。</li>
<li><code>[[:alpha:]])</code>：匹配单个字母。</li>
<li><code>???)</code>：匹配3个字符的单词。</li>
<li><code>*.txt)</code>：匹配<code>.txt</code>结尾。</li>
<li><code>*)</code>：匹配任意输入，通过作为<code>case</code>结构的最后一个模式。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> -n <span class="s2">&quot;输入一个字母或数字 &gt; &quot;</span>
<span class="nb">read</span> character
<span class="k">case</span> <span class="nv">$character</span> in
  <span class="o">[[</span>:lower:<span class="o">]]</span> <span class="p">|</span> <span class="o">[[</span>:upper:<span class="o">]]</span> <span class="o">)</span> <span class="nb">echo</span> <span class="s2">&quot;输入了字母 </span><span class="nv">$character</span><span class="s2">&quot;</span>
                              <span class="p">;;</span>
  <span class="o">[</span><span class="m">0</span>-9<span class="o">]</span> <span class="o">)</span>                     <span class="nb">echo</span> <span class="s2">&quot;输入了数字 </span><span class="nv">$character</span><span class="s2">&quot;</span>
                              <span class="p">;;</span>
  * <span class="o">)</span>                         <span class="nb">echo</span> <span class="s2">&quot;输入不符合要求&quot;</span>
<span class="k">esac</span>
</code></pre></div>

<p>上面例子中，使用通配符<code>[[:lower:]] | [[:upper:]]</code>匹配字母，<code>[0-9]</code>匹配数字。</p>
<p>Bash 4.0之前，<code>case</code>结构只能匹配一个条件，然后就会退出<code>case</code>结构。Bash 4.0之后，允许匹配多个条件，这时可以用<code>;;&amp;</code>终止每个条件块。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># test.sh</span>

<span class="nb">read</span> -n <span class="m">1</span> -p <span class="s2">&quot;Type a character &gt; &quot;</span>
<span class="nb">echo</span>
<span class="k">case</span> <span class="nv">$REPLY</span> in
  <span class="o">[[</span>:upper:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is upper case.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:lower:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is lower case.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:alpha:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is alphabetic.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:digit:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is a digit.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:graph:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is a visible character.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:punct:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is a punctuation symbol.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:space:<span class="o">]])</span>    <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is a whitespace character.&quot;</span> <span class="p">;;&amp;</span>
  <span class="o">[[</span>:xdigit:<span class="o">]])</span>   <span class="nb">echo</span> <span class="s2">&quot;&#39;</span><span class="nv">$REPLY</span><span class="s2">&#39; is a hexadecimal digit.&quot;</span> <span class="p">;;&amp;</span>
<span class="k">esac</span>
</code></pre></div>

<p>执行上面的脚本，会得到下面的结果。</p>
<div class="highlight"><pre><span></span><code>$ test.sh
Type a character &gt; a
<span class="s1">&#39;a&#39;</span> is lower <span class="k">case</span>.
<span class="s1">&#39;a&#39;</span> is alphabetic.
<span class="s1">&#39;a&#39;</span> is a visible character.
<span class="s1">&#39;a&#39;</span> is a hexadecimal digit.
</code></pre></div>

<p>可以看到条件语句结尾添加了<code>;;&amp;</code>以后，在匹配一个条件之后，并没有退出<code>case</code>结构，而是继续判断下一个条件。</p>
<h2 id="_69">参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php">The Linux Command Line</a>, William Shotts</li>
</ul>
<h1 id="_70">循环</h1>
<p>Bash 提供三种循环语法<code>for</code>、<code>while</code>和<code>until</code>。</p>
<h2 id="while">while 循环</h2>
<p><code>while</code>循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span> condition<span class="p">;</span> <span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>上面代码中，只要满足条件<code>condition</code>，就会执行命令<code>commands</code>。然后，再次判断是否满足条件<code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件<code>condition</code>可以使用<code>test</code>命令，跟<code>if</code>结构的判断条件写法一致。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">number</span><span class="o">=</span><span class="m">0</span>
<span class="k">while</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$number</span><span class="s2">&quot;</span> -lt <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;Number = </span><span class="nv">$number</span><span class="s2">&quot;</span>
  <span class="nv">number</span><span class="o">=</span><span class="k">$((</span>number <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，只要变量<code>$number</code>小于10，就会不断加1，直到<code>$number</code>等于10，然后退出循环。</p>
<p>关键字<code>do</code>可以跟<code>while</code>不在同一行，这时两者之间不需要使用分号分隔。</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span> <span class="nb">true</span>
<span class="k">do</span>
  <span class="nb">echo</span> <span class="s1">&#39;Hi, while looping ...&#39;</span><span class="p">;</span>
<span class="k">done</span>
</code></pre></div>

<p>上面的例子会无限循环，可以按下 Ctrl + c 停止。</p>
<p><code>while</code>循环写成一行，也是可以的。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">while</span> true<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s1">&#39;Hi, while looping ...&#39;</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div>

<p><code>while</code>的条件部分也可以是执行一个命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">while</span> <span class="nb">echo</span> <span class="s1">&#39;ECHO&#39;</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s1">&#39;Hi, while looping ...&#39;</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div>

<p>上面例子中，判断条件是<code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code>的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">while</span> true<span class="p">;</span> false<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s1">&#39;Hi, looping ...&#39;</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div>

<p>上面代码运行后，不会有任何输出，因为<code>while</code>的最后一个命令是<code>false</code>。</p>
<h2 id="until">until 循环</h2>
<p><code>until</code>循环与<code>while</code>循环恰好相反，只要不符合判断条件（判断条件失败），就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div class="highlight"><pre><span></span><code><span class="k">until</span> condition<span class="p">;</span> <span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>关键字<code>do</code>可以与<code>until</code>不写在同一行，这时两者之间不需要分号分隔。</p>
<div class="highlight"><pre><span></span><code><span class="k">until</span> condition
<span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">until</span> false<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s1">&#39;Hi, until looping ...&#39;</span><span class="p">;</span> <span class="k">done</span>
Hi, <span class="k">until</span> looping ...
Hi, <span class="k">until</span> looping ...
Hi, <span class="k">until</span> looping ...
^C
</code></pre></div>

<p>上面代码中，<code>until</code>的部分一直为<code>false</code>，导致命令无限运行，必须按下 Ctrl + c 终止。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">number</span><span class="o">=</span><span class="m">0</span>
<span class="k">until</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$number</span><span class="s2">&quot;</span> -ge <span class="m">10</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;Number = </span><span class="nv">$number</span><span class="s2">&quot;</span>
  <span class="nv">number</span><span class="o">=</span><span class="k">$((</span>number <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，只要变量<code>number</code>小于10，就会不断加1，直到<code>number</code>大于等于10，就退出循环。</p>
<p><code>until</code>的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div class="highlight"><pre><span></span><code><span class="k">until</span> cp <span class="nv">$1</span> <span class="nv">$2</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s1">&#39;Attempt to copy failed. waiting...&#39;</span>
  sleep <span class="m">5</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子表示，只要<code>cp $1 $2</code>这个命令执行不成功，就5分钟后再尝试一次，直到成功为止。</p>
<p><code>until</code>循环都可以转为<code>while</code>循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span> ! cp <span class="nv">$1</span> <span class="nv">$2</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s1">&#39;Attempt to copy failed. waiting...&#39;</span>
  sleep <span class="m">5</span>
<span class="k">done</span>
</code></pre></div>

<p>一般来说，<code>until</code>用得比较少，完全可以统一都使用<code>while</code>。</p>
<h2 id="forin">for...in 循环</h2>
<p><code>for...in</code>循环用于遍历列表的每一项。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> variable in list
<span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>上面语法中，<code>for</code>循环会依次从<code>list</code>列表中取出一项，作为变量<code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词<code>do</code>可以跟<code>for</code>写在同一行，两者使用分号分隔。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> variable in list<span class="p">;</span> <span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="k">for</span> i in word1 word2 word3<span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，<code>word1 word2 word3</code>是一个包含三个单词的列表，变量<code>i</code>依次等于<code>word1</code>、<code>word2</code>、<code>word3</code>，命令<code>echo $i</code>则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> i in *.png<span class="p">;</span> <span class="k">do</span>
  ls -l <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，<code>*.png</code>会替换成当前目录中所有 PNG 图片文件，变量<code>i</code>会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">count</span><span class="o">=</span><span class="m">0</span>
<span class="k">for</span> i in <span class="k">$(</span>cat ~/.bash_profile<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  <span class="nv">count</span><span class="o">=</span><span class="k">$((</span>count <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
  <span class="nb">echo</span> <span class="s2">&quot;Word </span><span class="nv">$count</span><span class="s2"> (</span><span class="nv">$i</span><span class="s2">) contains </span><span class="k">$(</span><span class="nb">echo</span> -n <span class="nv">$i</span> <span class="p">|</span> wc -c<span class="k">)</span><span class="s2"> characters&quot;</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，<code>cat ~/.bash_profile</code>命令会输出<code>~/.bash_profile</code>文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code>的部分可以省略，这时<code>list</code>默认等于脚本的所有参数<code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> filename<span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span>
<span class="k">done</span>

<span class="c1"># 等同于</span>

<span class="k">for</span> filename in <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span> <span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span>
<span class="k">done</span>
</code></pre></div>

<p>在函数体中也是一样的，<code>for...in</code>循环省略<code>in list</code>的部分，则<code>list</code>默认等于函数的所有参数。</p>
<h2 id="for">for 循环</h2>
<p><code>for</code>循环还支持 C 语言的循环语法。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="o">((</span> expression1<span class="p">;</span> expression2<span class="p">;</span> expression3 <span class="o">))</span><span class="p">;</span> <span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>上面代码中，<code>expression1</code>用来初始化循环条件，<code>expression2</code>用来决定循环结束的条件，<code>expression3</code>在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号<code>$</code>。</p>
<p>它等同于下面的<code>while</code>循环。</p>
<div class="highlight"><pre><span></span><code><span class="o">((</span> expression1 <span class="o">))</span>
<span class="k">while</span> <span class="o">((</span> expression2 <span class="o">))</span><span class="p">;</span> <span class="k">do</span>
  commands
  <span class="o">((</span> expression3 <span class="o">))</span>
<span class="k">done</span>
</code></pre></div>

<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="o">((</span> <span class="nv">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span> i&lt;<span class="m">5</span><span class="p">;</span> <span class="nv">i</span><span class="o">=</span>i+1 <span class="o">))</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>

<p>上面代码中，初始化变量<code>i</code>的值为0，循环执行的条件是<code>i</code>小于5。每次循环迭代结束时，<code>i</code>的值加1。</p>
<p><code>for</code>条件部分的三个语句，都可以省略。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="o">((</span><span class="p">;;</span><span class="o">))</span>
<span class="k">do</span>
  <span class="nb">read</span> var
  <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">break</span>
  <span class="k">fi</span>
<span class="k">done</span>
</code></pre></div>

<p>上面脚本会反复读取命令行输入，直到用户输入了一个点（<code>.</code>）位为止，才会跳出循环。</p>
<h2 id="breakcontinue">break，continue</h2>
<p>Bash 提供了两个内部命令<code>break</code>和<code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code>命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="k">for</span> number in <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span>
<span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;number is </span><span class="nv">$number</span><span class="s2">&quot;</span>
  <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$number</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;3&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">break</span>
  <span class="k">fi</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子只会打印3行结果。一旦变量<code>$number</code>等于3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code>命令立即终止本轮循环，开始执行下一轮循环。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="k">while</span> <span class="nb">read</span> -p <span class="s2">&quot;What file do you want to test?&quot;</span> filename
<span class="k">do</span>
  <span class="k">if</span> <span class="o">[</span> ! -e <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;The file does not exist.&quot;</span>
    <span class="k">continue</span>
  <span class="k">fi</span>

  <span class="nb">echo</span> <span class="s2">&quot;You entered a valid file..&quot;</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，只要用户输入的文件不存在，<code>continue</code>命令就会生效，直接进入下一轮循环（让用户重新输入文件名），不再执行后面的打印语句。</p>
<h2 id="select">select 结构</h2>
<p><code>select</code>结构主要用来生成简单的菜单。它的语法与<code>for...in</code>循环基本一致。</p>
<div class="highlight"><pre><span></span><code><span class="k">select</span> name
<span class="o">[</span>in list<span class="o">]</span>
<span class="k">do</span>
  commands
<span class="k">done</span>
</code></pre></div>

<p>Bash 会对<code>select</code>依次进行下面的处理。</p>
<ol>
<li><code>select</code>生成一个菜单，内容是列表<code>list</code>的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量<code>name</code>，该项的编号存入环境变量<code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体<code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># select.sh</span>

<span class="k">select</span> brand in Samsung Sony iphone symphony Walton
<span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;You have chosen </span><span class="nv">$brand</span><span class="s2">&quot;</span>
<span class="k">done</span>
</code></pre></div>

<p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div class="highlight"><pre><span></span><code>$ ./select.sh
<span class="m">1</span><span class="o">)</span> Samsung
<span class="m">2</span><span class="o">)</span> Sony
<span class="m">3</span><span class="o">)</span> iphone
<span class="m">4</span><span class="o">)</span> symphony
<span class="m">5</span><span class="o">)</span> Walton
<span class="c1">#?</span>
</code></pre></div>

<p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下<code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code>可以与<code>case</code>结合，针对不同项，执行不同的命令。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">&quot;Which Operating System do you like?&quot;</span>

<span class="k">select</span> os in Ubuntu LinuxMint Windows8 Windows7 WindowsXP
<span class="k">do</span>
  <span class="k">case</span> <span class="nv">$os</span> in
    <span class="s2">&quot;Ubuntu&quot;</span><span class="p">|</span><span class="s2">&quot;LinuxMint&quot;</span><span class="o">)</span>
      <span class="nb">echo</span> <span class="s2">&quot;I also use </span><span class="nv">$os</span><span class="s2">.&quot;</span>
    <span class="p">;;</span>
    <span class="s2">&quot;Windows8&quot;</span> <span class="p">|</span> <span class="s2">&quot;Windows10&quot;</span> <span class="p">|</span> <span class="s2">&quot;WindowsXP&quot;</span><span class="o">)</span>
      <span class="nb">echo</span> <span class="s2">&quot;Why don&#39;t you try Linux?&quot;</span>
    <span class="p">;;</span>
    *<span class="o">)</span>
      <span class="nb">echo</span> <span class="s2">&quot;Invalid entry.&quot;</span>
      <span class="nb">break</span>
    <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
</code></pre></div>

<p>上面例子中，<code>case</code>针对用户选择的不同项，执行不同的命令。</p>
<h2 id="_71">参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
<h1 id="bash_7">Bash 函数</h1>
<p>本章介绍 Bash 函数的用法。</p>
<h2 id="_72">简介</h2>
<p>函数（function）是可以重复使用的代码片段，有利于代码的复用。它与别名（alias）的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 第一种</span>
fn<span class="o">()</span> <span class="o">{</span>
  <span class="c1"># codes</span>
<span class="o">}</span>

<span class="c1"># 第二种</span>
<span class="k">function</span> fn<span class="o">()</span> <span class="o">{</span>
  <span class="c1"># codes</span>
<span class="o">}</span>
</code></pre></div>

<p>上面代码中，<code>fn</code>是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div class="highlight"><pre><span></span><code>hello<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;Hello </span><span class="nv">$1</span><span class="s2">&quot;</span>
<span class="o">}</span>
</code></pre></div>

<p>上面代码中，函数体里面的<code>$1</code>表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div class="highlight"><pre><span></span><code>$ hello world
hello world
</code></pre></div>

<p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div class="highlight"><pre><span></span><code>today<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> -n <span class="s2">&quot;Today&#39;s date is: &quot;</span>
  date +<span class="s2">&quot;%A, %B %-d, %Y&quot;</span>
<span class="o">}</span>
</code></pre></div>

<p>删除一个函数，可以使用<code>unset</code>命令。</p>
<div class="highlight"><pre><span></span><code><span class="nb">unset</span> -f functionName
</code></pre></div>

<p>查看当前 Shell 已经定义的所有函数，可以使用<code>declare</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -f
</code></pre></div>

<p>上面的<code>declare</code>命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合<code>more</code>或<code>less</code>使用。</p>
<p><code>declare</code>命令还支持查看单个函数的定义。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -f functionName
</code></pre></div>

<p><code>declare -F</code>可以输出所有已经定义的函数名，不含函数体。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -F
</code></pre></div>

<h2 id="_73">参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code>~<code>$9</code>：函数的第一个到第9个的参数。</li>
<li><code>$0</code>：函数所在的脚本名。</li>
<li><code>$#</code>：函数的参数总数。</li>
<li><code>$@</code>：函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>：函数的全部参数，参数之间使用变量<code>$IFS</code>值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于9个，那么第10个参数可以用<code>${10}</code>的形式引用，以此类推。</p>
<p>下面是一个示例脚本<code>test.sh</code>。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># test.sh</span>

<span class="k">function</span> alice <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;alice: </span><span class="nv">$@</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">: </span><span class="nv">$1</span><span class="s2"> </span><span class="nv">$2</span><span class="s2"> </span><span class="nv">$3</span><span class="s2"> </span><span class="nv">$4</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$#</span><span class="s2"> arguments&quot;</span>

<span class="o">}</span>

alice in wonderland
</code></pre></div>

<p>运行该脚本，结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash test.sh
alice: in wonderland
test.sh: in wonderland
<span class="m">2</span> arguments
</code></pre></div>

<p>上面例子中，由于函数<code>alice</code>只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span> log_msg <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;[`date &#39;+ %F %T&#39;` ]: </span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="o">}</span>
</code></pre></div>

<p>使用方法如下。</p>
<div class="highlight"><pre><span></span><code>$ log_msg <span class="s2">&quot;This is sample log message&quot;</span>
<span class="o">[</span> <span class="m">2018</span>-08-16 <span class="m">19</span>:56:34 <span class="o">]</span>: This is sample log message
</code></pre></div>

<h2 id="return">return 命令</h2>
<p><code>return</code>命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span> func_return_value <span class="o">{</span>
  <span class="k">return</span> <span class="m">10</span>
<span class="o">}</span>
</code></pre></div>

<p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用<code>$?</code>拿到返回值。</p>
<div class="highlight"><pre><span></span><code>$ func_return_value
$ <span class="nb">echo</span> <span class="s2">&quot;Value returned by function is: </span><span class="nv">$?</span><span class="s2">&quot;</span>
Value returned by <span class="k">function</span> is: <span class="m">10</span>
</code></pre></div>

<p><code>return</code>后面不跟参数，只用于返回也是可以的。</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span> name <span class="o">{</span>
  commands
  <span class="k">return</span>
<span class="o">}</span>
</code></pre></div>

<h2 id="local">全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 脚本 test.sh</span>
fn <span class="o">()</span> <span class="o">{</span>
  <span class="nv">foo</span><span class="o">=</span><span class="m">1</span>
  <span class="nb">echo</span> <span class="s2">&quot;fn: foo = </span><span class="nv">$foo</span><span class="s2">&quot;</span>
<span class="o">}</span>

fn
<span class="nb">echo</span> <span class="s2">&quot;global: foo = </span><span class="nv">$foo</span><span class="s2">&quot;</span>
</code></pre></div>

<p>上面脚本的运行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash test.sh
fn: <span class="nv">foo</span> <span class="o">=</span> <span class="m">1</span>
global: <span class="nv">foo</span> <span class="o">=</span> <span class="m">1</span>
</code></pre></div>

<p>上面例子中，变量<code>$foo</code>是在函数<code>fn</code>内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div class="highlight"><pre><span></span><code><span class="nv">foo</span><span class="o">=</span><span class="m">1</span>

fn <span class="o">()</span> <span class="o">{</span>
  <span class="nv">foo</span><span class="o">=</span><span class="m">2</span>
<span class="o">}</span>

<span class="nb">echo</span> <span class="nv">$foo</span>
</code></pre></div>

<p>上面代码执行后，输出的变量<code>$foo</code>值为2。</p>
<p>函数里面可以用<code>local</code>命令声明局部变量。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 脚本 test.sh</span>
fn <span class="o">()</span> <span class="o">{</span>
  <span class="nb">local</span> foo
  <span class="nv">foo</span><span class="o">=</span><span class="m">1</span>
  <span class="nb">echo</span> <span class="s2">&quot;fn: foo = </span><span class="nv">$foo</span><span class="s2">&quot;</span>
<span class="o">}</span>

fn
<span class="nb">echo</span> <span class="s2">&quot;global: foo = </span><span class="nv">$foo</span><span class="s2">&quot;</span>
</code></pre></div>

<p>上面脚本的运行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash test.sh
fn: <span class="nv">foo</span> <span class="o">=</span> <span class="m">1</span>
global: <span class="nv">foo</span> <span class="o">=</span>
</code></pre></div>

<p>上面例子中，<code>local</code>命令声明的<code>$foo</code>变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="_74">参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
<h1 id="_75">数组</h1>
<p>数组（array）是一个包含多个值的变量。成员的编号从0开始，数量没有上限，也没有要求成员被连续索引。</p>
<h2 id="_76">创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div class="highlight"><pre><span></span><code>ARRAY<span class="o">[</span>INDEX<span class="o">]=</span>value
</code></pre></div>

<p>上面语法中，<code>ARRAY</code>是数组的名字，可以是任意合法的变量名。<code>INDEX</code>是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是0， 而不是1。</p>
<p>下面创建一个三个成员的数组。</p>
<div class="highlight"><pre><span></span><code>$ array<span class="o">[</span><span class="m">0</span><span class="o">]=</span>val
$ array<span class="o">[</span><span class="m">1</span><span class="o">]=</span>val
$ array<span class="o">[</span><span class="m">2</span><span class="o">]=</span>val
</code></pre></div>

<p>数组也可以采用一次性赋值的方式创建。</p>
<div class="highlight"><pre><span></span><code><span class="nv">ARRAY</span><span class="o">=(</span>value1 value2 ... valueN<span class="o">)</span>

<span class="c1"># 等同于</span>

<span class="nv">ARRAY</span><span class="o">=(</span>
  value1
  value2
  value3
<span class="o">)</span>
</code></pre></div>

<p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">array</span><span class="o">=(</span>a b c<span class="o">)</span>
$ <span class="nv">array</span><span class="o">=([</span><span class="m">2</span><span class="o">]=</span>c <span class="o">[</span><span class="m">0</span><span class="o">]=</span>a <span class="o">[</span><span class="m">1</span><span class="o">]=</span>b<span class="o">)</span>

$ <span class="nv">days</span><span class="o">=(</span>Sun Mon Tue Wed Thu Fri Sat<span class="o">)</span>
$ <span class="nv">days</span><span class="o">=([</span><span class="m">0</span><span class="o">]=</span>Sun <span class="o">[</span><span class="m">1</span><span class="o">]=</span>Mon <span class="o">[</span><span class="m">2</span><span class="o">]=</span>Tue <span class="o">[</span><span class="m">3</span><span class="o">]=</span>Wed <span class="o">[</span><span class="m">4</span><span class="o">]=</span>Thu <span class="o">[</span><span class="m">5</span><span class="o">]=</span>Fri <span class="o">[</span><span class="m">6</span><span class="o">]=</span>Sat<span class="o">)</span>
</code></pre></div>

<p>只为某些值指定位置，也是可以的。</p>
<div class="highlight"><pre><span></span><code><span class="nv">names</span><span class="o">=(</span>hatter <span class="o">[</span><span class="m">5</span><span class="o">]=</span>duchess alice<span class="o">)</span>
</code></pre></div>

<p>上面例子中，<code>hatter</code>是数组的0号位置，<code>duchess</code>是5号位置，<code>alice</code>是6号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">mp3s</span><span class="o">=(</span> *.mp3 <span class="o">)</span>
</code></pre></div>

<p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用<code>declare -a</code>命令声明一个数组，也是可以的。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -a ARRAYNAME
</code></pre></div>

<p><code>read -a</code>命令则是将用户的命令行输入，读入一个数组。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">read</span> -a dice
</code></pre></div>

<p>上面命令将用户的命令行输入，读入数组<code>dice</code>。</p>
<h2 id="_77">读取数组</h2>
<h3 id="_78">读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">array</span><span class="p">[i]</span><span class="si">}</span>     <span class="c1"># i 是索引</span>
</code></pre></div>

<p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分<code>[i]</code>按照原样输出。</p>
<div class="highlight"><pre><span></span><code>$ array<span class="o">[</span><span class="m">0</span><span class="o">]=</span>a

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">array</span><span class="p">[0]</span><span class="si">}</span>
a

$ <span class="nb">echo</span> <span class="nv">$array</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>
a<span class="o">[</span><span class="m">0</span><span class="o">]</span>
</code></pre></div>

<p>上面例子中，数组的第一个元素是<code>a</code>。如果不加大括号，Bash 会直接读取<code>$array</code>首成员的值，然后将<code>[0]</code>按照原样输出。</p>
<h3 id="_79">读取所有成员</h3>
<p><code>@</code>和<code>*</code>是数组的特殊索引，表示返回数组的所有成员。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
a b c d e f
</code></pre></div>

<p>这两个特殊索引配合<code>for</code>循环，就可以用来遍历数组。</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> i in <span class="s2">&quot;</span><span class="si">${</span><span class="nv">names</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></div>

<p><code>@</code>和<code>*</code>放不放在双引号之中，是有差别的。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">activities</span><span class="o">=(</span> swimming <span class="s2">&quot;water skiing&quot;</span> canoeing <span class="s2">&quot;white-water rafting&quot;</span> surfing <span class="o">)</span>
$ <span class="k">for</span> act in <span class="si">${</span><span class="nv">activities</span><span class="p">[@]</span><span class="si">}</span><span class="p">;</span> <span class="se">\</span>
<span class="k">do</span> <span class="se">\</span>
<span class="nb">echo</span> <span class="s2">&quot;Activity: </span><span class="nv">$act</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
<span class="k">done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre></div>

<p>上面的例子中，数组<code>activities</code>实际包含5个元素，但是<code>for...in</code>循环直接遍历<code>${activities[@]}</code>，会导致返回7个结果。为了避免这种情况，一般把<code>${activities[@]}</code>放在双引号之中。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">for</span> act in <span class="s2">&quot;</span><span class="si">${</span><span class="nv">activities</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
<span class="k">do</span> <span class="se">\</span>
<span class="nb">echo</span> <span class="s2">&quot;Activity: </span><span class="nv">$act</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
<span class="k">done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing
</code></pre></div>

<p>上面例子中，<code>${activities[@]}</code>放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code>不放在双引号之中，跟<code>${activities[@]}</code>不放在双引号之中是一样的。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">for</span> act in <span class="si">${</span><span class="nv">activities</span><span class="p">[*]</span><span class="si">}</span><span class="p">;</span> <span class="se">\</span>
<span class="k">do</span> <span class="se">\</span>
<span class="nb">echo</span> <span class="s2">&quot;Activity: </span><span class="nv">$act</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
<span class="k">done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre></div>

<p><code>${activities[*]}</code>放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div class="highlight"><pre><span></span><code>$ <span class="k">for</span> act in <span class="s2">&quot;</span><span class="si">${</span><span class="nv">activities</span><span class="p">[*]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
<span class="k">do</span> <span class="se">\</span>
<span class="nb">echo</span> <span class="s2">&quot;Activity: </span><span class="nv">$act</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
<span class="k">done</span>

Activity: swimming water skiing canoeing white-water rafting surfing
</code></pre></div>

<p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">hobbies</span><span class="o">=(</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">activities</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">)</span>
</code></pre></div>

<p>上面例子中，数组<code>activities</code>被拷贝给了另一个数组<code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">hobbies</span><span class="o">=(</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">activities</span><span class="p">[@]</span><span class="s2">&quot; diving )</span>
</code></pre></div>

<p>上面例子中，新数组<code>hobbies</code>在数组<code>activities</code>的所有成员之后，又添加了一个成员。</p>
<h3 id="_80">默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用<code>0</code>号位置。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">declare</span> -a foo
$ <span class="nv">foo</span><span class="o">=</span>A
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[0]</span><span class="si">}</span>
A
</code></pre></div>

<p>上面例子中，<code>foo</code>是一个数组，赋值的时候不指定位置，实际上是给<code>foo[0]</code>赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是<code>0</code>号位置的数组元素。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="si">}</span>
a
$ <span class="nb">echo</span> <span class="nv">$foo</span>
a
</code></pre></div>

<p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是<code>0</code>号位置。</p>
<h2 id="_81">数组的长度</h2>
<p>要想知道数组的长度（即一共包含多少成员），可以使用下面两种语法。</p>
<div class="highlight"><pre><span></span><code><span class="si">${#</span><span class="nv">array</span><span class="p">[*]</span><span class="si">}</span>
<span class="si">${#</span><span class="nv">array</span><span class="p">[@]</span><span class="si">}</span>
</code></pre></div>

<p>下面是一个例子。</p>
<div class="highlight"><pre><span></span><code>$ a<span class="o">[</span><span class="m">100</span><span class="o">]=</span>foo

$ <span class="nb">echo</span> <span class="si">${#</span><span class="nv">a</span><span class="p">[*]</span><span class="si">}</span>
<span class="m">1</span>

$ <span class="nb">echo</span> <span class="si">${#</span><span class="nv">a</span><span class="p">[@]</span><span class="si">}</span>
<span class="m">1</span>
</code></pre></div>

<p>上面例子中，把字符串赋值给<code>100</code>位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div class="highlight"><pre><span></span><code>$ a<span class="o">[</span><span class="m">100</span><span class="o">]=</span>foo
$ <span class="nb">echo</span> <span class="si">${#</span><span class="nv">a</span><span class="p">[100]</span><span class="si">}</span>
<span class="m">3</span>
</code></pre></div>

<p>上面例子中，<code>${#a[100]}</code>实际上是返回数组第100号成员<code>a[100]</code>的值（<code>foo</code>）的字符串长度。</p>
<h2 id="_82">提取数组序号</h2>
<p><code>${!array[@]}</code>或<code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">arr</span><span class="o">=([</span><span class="m">5</span><span class="o">]=</span>a <span class="o">[</span><span class="m">9</span><span class="o">]=</span>b <span class="o">[</span><span class="m">23</span><span class="o">]=</span>c<span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="p">!arr[@]</span><span class="si">}</span>
<span class="m">5</span> <span class="m">9</span> <span class="m">23</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="p">!arr[*]</span><span class="si">}</span>
<span class="m">5</span> <span class="m">9</span> <span class="m">23</span>
</code></pre></div>

<p>上面例子中，数组的5、9、23号位置有值。</p>
<p>利用这个语法，也可以通过<code>for</code>循环遍历数组。</p>
<div class="highlight"><pre><span></span><code><span class="nv">arr</span><span class="o">=(</span>a b c d<span class="o">)</span>

<span class="k">for</span> i in <span class="si">${</span><span class="p">!arr[@]</span><span class="si">}</span><span class="p">;</span><span class="k">do</span>
  <span class="nb">echo</span> <span class="si">${</span><span class="nv">arr</span><span class="p">[i]</span><span class="si">}</span>
<span class="k">done</span>
</code></pre></div>

<h2 id="_83">提取数组成员</h2>
<p><code>${array[@]:position:length}</code>的语法可以提取数组成员。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">food</span><span class="o">=(</span> apples bananas cucumbers dates eggs fajitas grapes <span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">food</span><span class="p">[@]:</span><span class="nv">1</span><span class="p">:</span><span class="nv">1</span><span class="si">}</span>
bananas
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">food</span><span class="p">[@]:</span><span class="nv">1</span><span class="p">:</span><span class="nv">3</span><span class="si">}</span>
bananas cucumbers dates
</code></pre></div>

<p>上面例子中，<code>${food[@]:1:1}</code>返回从数组1号位置开始的1个成员，<code>${food[@]:1:3}</code>返回从1号位置开始的3个成员。</p>
<p>如果省略长度参数<code>length</code>，则返回从指定位置开始的所有成员。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">food</span><span class="p">[@]:</span><span class="nv">4</span><span class="si">}</span>
eggs fajitas grapes
</code></pre></div>

<p>上面例子返回从4号位置开始到结束的所有成员。</p>
<h2 id="_84">追加数组成员</h2>
<p>数组末尾追加成员，可以使用<code>+=</code>赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=(</span>a b c<span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
a b c

$ <span class="nv">foo</span><span class="o">+=(</span>d e f<span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
a b c d e f
</code></pre></div>

<h2 id="_85">删除数组</h2>
<p>删除一个数组成员，使用<code>unset</code>命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
a b c d e f

$ <span class="nb">unset</span> foo<span class="o">[</span><span class="m">2</span><span class="o">]</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
a b d e f
</code></pre></div>

<p>上面例子中，删除了数组中的第三个元素，下标为2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
$ foo<span class="o">[</span><span class="m">1</span><span class="o">]=</span><span class="s1">&#39;&#39;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
a c d e f
</code></pre></div>

<p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div class="highlight"><pre><span></span><code>$ foo<span class="o">[</span><span class="m">1</span><span class="o">]=</span>
</code></pre></div>

<p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">foo</span><span class="o">=(</span>a b c d e f<span class="o">)</span>
$ <span class="nv">foo</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">foo</span><span class="p">[@]</span><span class="si">}</span>
b c d e f
</code></pre></div>

<p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code>可以清空整个数组。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">unset</span> ARRAY

$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">ARRAY</span><span class="p">[*]</span><span class="si">}</span>
&lt;--no output--&gt;
</code></pre></div>

<h2 id="_86">关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code>可以声明关联数组。</p>
<div class="highlight"><pre><span></span><code><span class="nb">declare</span> -A colors
colors<span class="o">[</span><span class="s2">&quot;red&quot;</span><span class="o">]=</span><span class="s2">&quot;#ff0000&quot;</span>
colors<span class="o">[</span><span class="s2">&quot;green&quot;</span><span class="o">]=</span><span class="s2">&quot;#00ff00&quot;</span>
colors<span class="o">[</span><span class="s2">&quot;blue&quot;</span><span class="o">]=</span><span class="s2">&quot;#0000ff&quot;</span>
</code></pre></div>

<p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有<code>-A</code>选项的<code>declare</code>命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div class="highlight"><pre><span></span><code><span class="nb">echo</span> <span class="si">${</span><span class="nv">colors</span><span class="p">[</span><span class="s2">&quot;blue&quot;</span><span class="p">]</span><span class="si">}</span>
</code></pre></div>

<h1 id="set">set 命令</h1>
<p><code>set</code>命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍<code>set</code>的基本用法，帮助你写出更安全的 Bash 脚本。</p>
<h2 id="_87">简介</h2>
<p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
</code></pre></div>

<p>上面代码中，<code>script.sh</code>是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code>命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">官方手册</a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">set</span>
</code></pre></div>

<h2 id="set-u">set -u</h2>
<p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>

<span class="nb">echo</span> <span class="nv">$a</span>
<span class="nb">echo</span> bar
</code></pre></div>

<p>上面代码中，<code>$a</code>是一个不存在的变量。执行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh

bar
</code></pre></div>

<p>可以看到，<code>echo $a</code>输出了一个空行，Bash 忽略了不存在的<code>$a</code>，然后继续执行<code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code>就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>
<span class="nb">set</span> -u

<span class="nb">echo</span> <span class="nv">$a</span>
<span class="nb">echo</span> bar
</code></pre></div>

<p>运行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre></div>

<p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code>还有另一种写法<code>-o nounset</code>，两者是等价的。</p>
<div class="highlight"><pre><span></span><code><span class="nb">set</span> -o nounset
</code></pre></div>

<h2 id="set-x">set -x</h2>
<p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>
<span class="nb">set</span> -x

<span class="nb">echo</span> bar
</code></pre></div>

<p>执行上面的脚本，结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
+ <span class="nb">echo</span> bar
bar
</code></pre></div>

<p>可以看到，执行<code>echo bar</code>之前，该命令会先打印出来，行首以<code>+</code>表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code>还有另一种写法<code>-o xtrace</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nb">set</span> -o xtrace
</code></pre></div>

<p>脚本当中如果要关闭命令输出，可以使用<code>set +x</code>。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">number</span><span class="o">=</span><span class="m">1</span>

<span class="nb">set</span> -x
<span class="k">if</span> <span class="o">[</span> <span class="nv">$number</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Number equals 1&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Number does not equal 1&quot;</span>
<span class="k">fi</span>
<span class="nb">set</span> +x
</code></pre></div>

<p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="bash_8">Bash 的错误处理</h2>
<p>如果脚本里面有运行失败的命令（返回值非<code>0</code>），Bash 默认会继续执行后面的命令。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>

foo
<span class="nb">echo</span> bar
</code></pre></div>

<p>上面脚本中，<code>foo</code>是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
script.sh:行3: foo: 未找到命令
bar
</code></pre></div>

<p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<div class="highlight"><pre><span></span><code><span class="nb">command</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
</code></pre></div>

<p>上面的写法表示只要<code>command</code>有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 写法一</span>
<span class="nb">command</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">&quot;command failed&quot;</span><span class="p">;</span> <span class="nb">exit</span> <span class="m">1</span><span class="p">;</span> <span class="o">}</span>

<span class="c1"># 写法二</span>
<span class="k">if</span> ! command<span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;command failed&quot;</span><span class="p">;</span> <span class="nb">exit</span> <span class="m">1</span><span class="p">;</span> <span class="k">fi</span>

<span class="c1"># 写法三</span>
<span class="nb">command</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;command failed&quot;</span><span class="p">;</span> <span class="nb">exit</span> <span class="m">1</span><span class="p">;</span> <span class="k">fi</span>
</code></pre></div>

<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<div class="highlight"><pre><span></span><code>command1 <span class="o">&amp;&amp;</span> command2
</code></pre></div>

<h2 id="set-e">set -e</h2>
<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>
<span class="nb">set</span> -e

foo
<span class="nb">echo</span> bar
</code></pre></div>

<p>执行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
script.sh:行4: foo: 未找到命令
</code></pre></div>

<p>可以看到，第4行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nb">set</span> +e
command1
command2
<span class="nb">set</span> -e
</code></pre></div>

<p>上面代码中，<code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。</p>
<p>还有一种方法是使用<code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="nb">set</span> -e

foo <span class="o">||</span> <span class="nb">true</span>
<span class="nb">echo</span> bar
</code></pre></div>

<p>上面代码中，<code>true</code>使得这一行语句总是会执行成功，后面的<code>echo bar</code>会执行。</p>
<p><code>-e</code>还有另一种写法<code>-o errexit</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nb">set</span> -o errexit
</code></pre></div>

<h2 id="set-o-pipefail">set -o pipefail</h2>
<p><code>set -e</code>有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符（<code>|</code>）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。</p>
<p>请看下面这个例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>
<span class="nb">set</span> -e

foo <span class="p">|</span> <span class="nb">echo</span> a
<span class="nb">echo</span> bar
</code></pre></div>

<p>执行结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
a
script.sh:行4: foo: 未找到命令
bar
</code></pre></div>

<p>上面代码中，<code>foo</code>是一个不存在的命令，但是<code>foo | echo a</code>这个管道命令会执行成功，导致后面的<code>echo bar</code>会继续执行。</p>
<p><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/usr/bin/env bash</span>
<span class="nb">set</span> -eo pipefail

foo <span class="p">|</span> <span class="nb">echo</span> a
<span class="nb">echo</span> bar
</code></pre></div>

<p>运行后，结果如下。</p>
<div class="highlight"><pre><span></span><code>$ bash script.sh
a
script.sh:行4: foo: 未找到命令
</code></pre></div>

<p>可以看到，<code>echo bar</code>没有执行。</p>
<h2 id="_88">其他参数</h2>
<p><code>set</code>命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>：等同于<code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>：等同于<code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>：等同于<code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
</ul>
<p>上面的<code>-f</code>和<code>-v</code>参数，可以分别使用<code>set +f</code>、<code>set +v</code>关闭。</p>
<h2 id="set_1">set 命令总结</h2>
<p>上面重点介绍的<code>set</code>命令的四个参数，一般都放在一起使用。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 写法一</span>
<span class="nb">set</span> -euxo pipefail

<span class="c1"># 写法二</span>
<span class="nb">set</span> -eux
<span class="nb">set</span> -o pipefail
</code></pre></div>

<p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<div class="highlight"><pre><span></span><code>$ bash -euxo pipefail script.sh
</code></pre></div>

<h2 id="shopt_1">shopt 命令</h2>
<p><code>shopt</code>命令用来调整 Shell 的参数，跟<code>set</code>命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code>是从 Ksh 继承的，属于 POSIX 规范的一部分，而<code>shopt</code>是 Bash 特有的。</p>
<p>直接输入<code>shopt</code>可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span>
</code></pre></div>

<p><code>shopt</code>命令后面跟着参数名，可以查询该参数是否打开。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> globstar
globstar  off
</code></pre></div>

<p>上面例子表示<code>globstar</code>参数默认是关闭的。</p>
<p><strong>（1）-s</strong></p>
<p><code>-s</code>用来打开某个参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -s optionNameHere
</code></pre></div>

<p><strong>（2）-u</strong></p>
<p><code>-u</code>用来关闭某个参数。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -u optionNameHere
</code></pre></div>

<p>举例来说，<code>histappend</code>这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -u histappend
</code></pre></div>

<p><strong>（3）-q</strong></p>
<p><code>-q</code>的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态（<code>$?</code>）表示查询结果。如果状态为<code>0</code>，表示该参数打开；如果为<code>1</code>，表示该参数关闭。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">shopt</span> -q globstar
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</code></pre></div>

<p>上面命令查询<code>globstar</code>参数是否打开。返回状态为<code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供<code>if</code>条件结构使用。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="nb">shopt</span> -q globstar<span class="p">;</span> <span class="k">then</span>
  ...
<span class="k">if</span>
</code></pre></div>

<h2 id="_89">参考链接</h2>
<ul>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">The Set Builtin</a></li>
<li><a href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/">Safer bash scripts with 'set -euxo pipefail'</a></li>
<li><a href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/">Writing Robust Bash Shell Scripts</a></li>
</ul>
<h1 id="_90">脚本除错</h1>
<p>本章介绍如何对 Shell 脚本除错。</p>
<h2 id="_91">常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#! /bin/bash</span>

<span class="nv">dir_name</span><span class="o">=</span>/path/not/exist

<span class="nb">cd</span> <span class="nv">$dir_name</span>
rm *
</code></pre></div>

<p>上面脚本中，如果目录<code>$dir_name</code>不存在，<code>cd $dir_name</code>命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致<code>rm *</code>命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div class="highlight"><pre><span></span><code><span class="nb">cd</span> <span class="nv">$dir_name</span> <span class="o">&amp;&amp;</span> rm *
</code></pre></div>

<p>上面脚本中，只有<code>cd $dir_name</code>执行成功，才会执行<code>rm *</code>。但是，如果变量<code>$dir_name</code>为空，<code>cd</code>就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div class="highlight"><pre><span></span><code><span class="o">[[</span> -d <span class="nv">$dir_name</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="nv">$dir_name</span> <span class="o">&amp;&amp;</span> rm *
</code></pre></div>

<p>上面代码中，先判断目录<code>$dir_name</code>是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div class="highlight"><pre><span></span><code><span class="o">[[</span> -d <span class="nv">$dir_name</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="nv">$dir_name</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> rm *
</code></pre></div>

<p>上面命令中，<code>echo rm *</code>不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash-x"><code>bash</code>的<code>-x</code>参数</h2>
<p><code>bash</code>的<code>-x</code>参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本<code>script.sh</code>。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># script.sh</span>
<span class="nb">echo</span> hello world
</code></pre></div>

<p>加上<code>-x</code>参数，执行每条命令之前，都会显示该命令。</p>
<div class="highlight"><pre><span></span><code>$ bash -x script.sh
+ <span class="nb">echo</span> hello world
hello world
</code></pre></div>

<p>上面例子中，行首为<code>+</code>的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个<code>-x</code>写在脚本内部的例子。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#! /bin/bash -x</span>
<span class="c1"># trouble: script to demonstrate common errors</span>

<span class="nv">number</span><span class="o">=</span><span class="m">1</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$number</span> <span class="o">=</span> <span class="m">1</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Number is equal to 1.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Number is not equal to 1.&quot;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面的脚本执行之后，会输出每一行命令。</p>
<div class="highlight"><pre><span></span><code>$ trouble
+ <span class="nv">number</span><span class="o">=</span><span class="m">1</span>
+ <span class="s1">&#39;[&#39;</span> <span class="nv">1</span> <span class="o">=</span> <span class="m">1</span> <span class="s1">&#39;]&#39;</span>
+ <span class="nb">echo</span> <span class="s1">&#39;Number is equal to 1.&#39;</span>
Number is equal to <span class="m">1</span>.
</code></pre></div>

<p>输出的命令之前的<code>+</code>号，是由系统变量<code>PS4</code>决定，可以修改这个变量。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">export</span> <span class="nv">PS4</span><span class="o">=</span><span class="s1">&#39;$LINENO + &#39;</span>
$ trouble
<span class="m">5</span> + <span class="nv">number</span><span class="o">=</span><span class="m">1</span>
<span class="m">7</span> + <span class="s1">&#39;[&#39;</span> <span class="nv">1</span> <span class="o">=</span> <span class="m">1</span> <span class="s1">&#39;]&#39;</span>
<span class="m">8</span> + <span class="nb">echo</span> <span class="s1">&#39;Number is equal to 1.&#39;</span>
Number is equal to <span class="m">1</span>.
</code></pre></div>

<p>另外，<code>set</code>命令也可以设置 Shell 的行为参数，有利于脚本除错，详见《set 命令》一章。</p>
<h2 id="_92">环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3 id="lineno">LINENO</h3>
<p>变量<code>LINENO</code>返回它在脚本里面的行号。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">&quot;This is line </span><span class="nv">$LINENO</span><span class="s2">&quot;</span>
</code></pre></div>

<p>执行上面的脚本<code>test.sh</code>，<code>$LINENO</code>会返回<code>3</code>。</p>
<div class="highlight"><pre><span></span><code>$ ./test.sh
This is line <span class="m">3</span>
</code></pre></div>

<h3 id="funcname">FUNCNAME</h3>
<p>变量<code>FUNCNAME</code>返回一个数组，内容是当前的函数调用堆栈。该数组的0号成员是当前调用的函数，1号成员是调用当前函数的函数，以此类推。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="k">function</span> func1<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: FUNCNAME0 is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: FUNCNAME1 is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: FUNCNAME2 is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[2]</span><span class="si">}</span><span class="s2">&quot;</span>
  func2
<span class="o">}</span>

<span class="k">function</span> func2<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: FUNCNAME0 is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: FUNCNAME1 is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: FUNCNAME2 is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[2]</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="o">}</span>

func1
</code></pre></div>

<p>执行上面的脚本<code>test.sh</code>，结果如下。</p>
<div class="highlight"><pre><span></span><code>$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main
</code></pre></div>

<p>上面例子中，执行<code>func1</code>时，变量<code>FUNCNAME</code>的0号成员是<code>func1</code>，1号成员是调用<code>func1</code>的主脚本<code>main</code>。执行<code>func2</code>时，变量<code>FUNCNAME</code>的0号成员是<code>func2</code>，1号成员是调用<code>func2</code>的<code>func1</code>。</p>
<h3 id="bash_source">BASH_SOURCE</h3>
<p>变量<code>BASH_SOURCE</code>返回一个数组，内容是当前的脚本调用堆栈。该数组的0号成员是当前执行的脚本，1号成员是调用当前脚本的脚本，以此类推，跟变量<code>FUNCNAME</code>是一一对应关系。</p>
<p>下面有两个子脚本<code>lib1.sh</code>和<code>lib2.sh</code>。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># lib1.sh</span>
<span class="k">function</span> func1<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: BASH_SOURCE0 is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: BASH_SOURCE1 is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: BASH_SOURCE2 is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[2]</span><span class="si">}</span><span class="s2">&quot;</span>
  func2
<span class="o">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># lib2.sh</span>
<span class="k">function</span> func2<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: BASH_SOURCE0 is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: BASH_SOURCE1 is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: BASH_SOURCE2 is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[2]</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="o">}</span>
</code></pre></div>

<p>然后，主脚本<code>main.sh</code>调用上面两个子脚本。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># main.sh</span>

<span class="nb">source</span> lib1.sh
<span class="nb">source</span> lib2.sh

func1
</code></pre></div>

<p>执行主脚本<code>main.sh</code>，会得到下面的结果。</p>
<div class="highlight"><pre><span></span><code>$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh
</code></pre></div>

<p>上面例子中，执行函数<code>func1</code>时，变量<code>BASH_SOURCE</code>的0号成员是<code>func1</code>所在的脚本<code>lib1.sh</code>，1号成员是主脚本<code>main.sh</code>；执行函数<code>func2</code>时，变量<code>BASH_SOURCE</code>的0号成员是<code>func2</code>所在的脚本<code>lib2.sh</code>，1号成员是调用<code>func2</code>的脚本<code>lib1.sh</code>。</p>
<h3 id="bash_lineno">BASH_LINENO</h3>
<p>变量<code>BASH_LINENO</code>返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code>跟<code>${FUNCNAME[$i]}</code>是一一对应关系，表示<code>${FUNCNAME[$i]}</code>在调用它的脚本文件<code>${BASH_SOURCE[$i+1]}</code>里面的行号。</p>
<p>下面有两个子脚本<code>lib1.sh</code>和<code>lib2.sh</code>。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># lib1.sh</span>
<span class="k">function</span> func1<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: BASH_LINENO is </span><span class="si">${</span><span class="nv">BASH_LINENO</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: FUNCNAME is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func1: BASH_SOURCE is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span>

  func2
<span class="o">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># lib2.sh</span>
<span class="k">function</span> func2<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: BASH_LINENO is </span><span class="si">${</span><span class="nv">BASH_LINENO</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: FUNCNAME is </span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;func2: BASH_SOURCE is </span><span class="si">${</span><span class="nv">BASH_SOURCE</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="o">}</span>
</code></pre></div>

<p>然后，主脚本<code>main.sh</code>调用上面两个子脚本。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># main.sh</span>

<span class="nb">source</span> lib1.sh
<span class="nb">source</span> lib2.sh

func1
</code></pre></div>

<p>执行主脚本<code>main.sh</code>，会得到下面的结果。</p>
<div class="highlight"><pre><span></span><code>$ ./main.sh
func1: BASH_LINENO is <span class="m">7</span>
func1: FUNCNAME is func1
func1: BASH_SOURCE is main.sh
func2: BASH_LINENO is <span class="m">8</span>
func2: FUNCNAME is func2
func2: BASH_SOURCE is lib1.sh
</code></pre></div>

<p>上面例子中，函数<code>func1</code>是在<code>main.sh</code>的第7行调用，函数<code>func2</code>是在<code>lib1.sh</code>的第8行调用的。</p>
<h1 id="mktemp-trap">mktemp 命令，trap 命令</h1>
<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在<code>/tmp</code>目录里面创建文件或目录，这样做有很多弊端，使用<code>mktemp</code>命令是最安全的做法。</p>
<h2 id="_93">临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在<code>/tmp</code>目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code>目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div class="highlight"><pre><span></span><code>$ touch /tmp/info.txt
$ ls -l /tmp/info.txt
-rw-r--r-- <span class="m">1</span> ruanyf ruanyf <span class="m">0</span> 12月 <span class="m">28</span> <span class="m">17</span>:12 /tmp/info.txt
</code></pre></div>

<p>上面命令在<code>/tmp</code>目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件（使用<code>trap</code>命令）。</li>
</ul>
</blockquote>
<h2 id="mktemp">mktemp 命令的用法</h2>
<p><code>mktemp</code>命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行<code>mktemp</code>命令，就能生成一个临时文件。</p>
<div class="highlight"><pre><span></span><code>$ mktemp
/tmp/tmp.4GcsWSG4vj

$ ls -l /tmp/tmp.4GcsWSG4vj
-rw------- <span class="m">1</span> ruanyf ruanyf <span class="m">0</span> 12月 <span class="m">28</span> <span class="m">12</span>:49 /tmp/tmp.4GcsWSG4vj
</code></pre></div>

<p>上面命令中，<code>mktemp</code>命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用<code>mktemp</code>命令的用法如下。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">TMPFILE</span><span class="o">=</span><span class="k">$(</span>mktemp<span class="k">)</span>
<span class="nb">echo</span> <span class="s2">&quot;Our temp file is </span><span class="nv">$TMPFILE</span><span class="s2">&quot;</span>
</code></pre></div>

<p>为了确保临时文件创建成功，<code>mktemp</code>命令后面最好使用 OR 运算符（<code>||</code>），保证创建失败时退出脚本。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nv">TMPFILE</span><span class="o">=</span><span class="k">$(</span>mktemp<span class="k">)</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
<span class="nb">echo</span> <span class="s2">&quot;Our temp file is </span><span class="nv">$TMPFILE</span><span class="s2">&quot;</span>
</code></pre></div>

<p>为了保证脚本退出时临时文件被删除，可以使用<code>trap</code>命令指定退出时的清除操作。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">trap</span> <span class="s1">&#39;rm -f &quot;$TMPFILE&quot;&#39;</span> EXIT

<span class="nv">TMPFILE</span><span class="o">=</span><span class="k">$(</span>mktemp<span class="k">)</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
<span class="nb">echo</span> <span class="s2">&quot;Our temp file is </span><span class="nv">$TMPFILE</span><span class="s2">&quot;</span>
</code></pre></div>

<h2 id="mktemp_1">mktemp 命令的参数</h2>
<p><code>-d</code>参数可以创建一个临时目录。</p>
<div class="highlight"><pre><span></span><code>$ mktemp -d
/tmp/tmp.Wcau5UjmN6
</code></pre></div>

<p><code>-p</code>参数可以指定临时文件所在的目录。默认是使用<code>$TMPDIR</code>环境变量指定的目录，如果这个变量没设置，那么使用<code>/tmp</code>目录。</p>
<div class="highlight"><pre><span></span><code>$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3
</code></pre></div>

<p><code>-t</code>参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的<code>X</code>字符，表示随机字符，建议至少使用六个<code>X</code>。默认的文件名模板是<code>tmp.</code>后接十个随机字符。</p>
<div class="highlight"><pre><span></span><code>$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV
</code></pre></div>

<h2 id="trap">trap 命令</h2>
<p><code>trap</code>命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT（中断），即按 Ctrl + C 所产生的信号。<code>trap</code>命令的<code>-l</code>参数，可以列出所有的系统信号。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">trap</span> -l
 <span class="m">1</span><span class="o">)</span> SIGHUP   <span class="m">2</span><span class="o">)</span> SIGINT   <span class="m">3</span><span class="o">)</span> SIGQUIT  <span class="m">4</span><span class="o">)</span> SIGILL   <span class="m">5</span><span class="o">)</span> SIGTRAP
 <span class="m">6</span><span class="o">)</span> SIGABRT  <span class="m">7</span><span class="o">)</span> SIGBUS   <span class="m">8</span><span class="o">)</span> SIGFPE   <span class="m">9</span><span class="o">)</span> SIGKILL <span class="m">10</span><span class="o">)</span> SIGUSR1
<span class="m">11</span><span class="o">)</span> SIGSEGV <span class="m">12</span><span class="o">)</span> SIGUSR2 <span class="m">13</span><span class="o">)</span> SIGPIPE <span class="m">14</span><span class="o">)</span> SIGALRM <span class="m">15</span><span class="o">)</span> SIGTERM
<span class="m">16</span><span class="o">)</span> SIGSTKFLT   <span class="m">17</span><span class="o">)</span> SIGCHLD <span class="m">18</span><span class="o">)</span> SIGCONT <span class="m">19</span><span class="o">)</span> SIGSTOP <span class="m">20</span><span class="o">)</span> SIGTSTP
<span class="m">21</span><span class="o">)</span> SIGTTIN <span class="m">22</span><span class="o">)</span> SIGTTOU <span class="m">23</span><span class="o">)</span> SIGURG  <span class="m">24</span><span class="o">)</span> SIGXCPU <span class="m">25</span><span class="o">)</span> SIGXFSZ
<span class="m">26</span><span class="o">)</span> SIGVTALRM   <span class="m">27</span><span class="o">)</span> SIGPROF <span class="m">28</span><span class="o">)</span> SIGWINCH    <span class="m">29</span><span class="o">)</span> SIGIO   <span class="m">30</span><span class="o">)</span> SIGPWR
<span class="m">31</span><span class="o">)</span> SIGSYS  <span class="m">34</span><span class="o">)</span> SIGRTMIN    <span class="m">35</span><span class="o">)</span> SIGRTMIN+1  <span class="m">36</span><span class="o">)</span> SIGRTMIN+2  <span class="m">37</span><span class="o">)</span> SIGRTMIN+3
<span class="m">38</span><span class="o">)</span> SIGRTMIN+4  <span class="m">39</span><span class="o">)</span> SIGRTMIN+5  <span class="m">40</span><span class="o">)</span> SIGRTMIN+6  <span class="m">41</span><span class="o">)</span> SIGRTMIN+7  <span class="m">42</span><span class="o">)</span> SIGRTMIN+8
<span class="m">43</span><span class="o">)</span> SIGRTMIN+9  <span class="m">44</span><span class="o">)</span> SIGRTMIN+10 <span class="m">45</span><span class="o">)</span> SIGRTMIN+11 <span class="m">46</span><span class="o">)</span> SIGRTMIN+12 <span class="m">47</span><span class="o">)</span> SIGRTMIN+13
<span class="m">48</span><span class="o">)</span> SIGRTMIN+14 <span class="m">49</span><span class="o">)</span> SIGRTMIN+15 <span class="m">50</span><span class="o">)</span> SIGRTMAX-14 <span class="m">51</span><span class="o">)</span> SIGRTMAX-13 <span class="m">52</span><span class="o">)</span> SIGRTMAX-12
<span class="m">53</span><span class="o">)</span> SIGRTMAX-11 <span class="m">54</span><span class="o">)</span> SIGRTMAX-10 <span class="m">55</span><span class="o">)</span> SIGRTMAX-9  <span class="m">56</span><span class="o">)</span> SIGRTMAX-8  <span class="m">57</span><span class="o">)</span> SIGRTMAX-7
<span class="m">58</span><span class="o">)</span> SIGRTMAX-6  <span class="m">59</span><span class="o">)</span> SIGRTMAX-5  <span class="m">60</span><span class="o">)</span> SIGRTMAX-4  <span class="m">61</span><span class="o">)</span> SIGRTMAX-3  <span class="m">62</span><span class="o">)</span> SIGRTMAX-2
<span class="m">63</span><span class="o">)</span> SIGRTMAX-1  <span class="m">64</span><span class="o">)</span> SIGRTMAX
</code></pre></div>

<p><code>trap</code>的命令格式如下。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">trap</span> <span class="o">[</span>动作<span class="o">]</span> <span class="o">[</span>信号1<span class="o">]</span> <span class="o">[</span>信号2<span class="o">]</span> ...
</code></pre></div>

<p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP：编号1，脚本与所在的终端脱离联系。</li>
<li>INT：编号2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL：编号9，该信号用于杀死进程。</li>
<li>TERM：编号15，这是<code>kill</code>命令发出的默认信号。</li>
<li>EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code>命令响应<code>EXIT</code>信号的写法如下。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">trap</span> <span class="s1">&#39;rm -f &quot;$TMPFILE&quot;&#39;</span> EXIT
</code></pre></div>

<p>上面命令中，脚本遇到<code>EXIT</code>信号时，就会执行<code>rm -f "$TMPFILE"</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">trap</span> <span class="s1">&#39;rm -f &quot;$TMPFILE&quot;&#39;</span> EXIT

<span class="nv">TMPFILE</span><span class="o">=</span><span class="k">$(</span>mktemp<span class="k">)</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
ls /etc &gt; <span class="nv">$TMPFILE</span>
<span class="k">if</span> grep -qi <span class="s2">&quot;kernel&quot;</span> <span class="nv">$TMPFILE</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s1">&#39;find&#39;</span>
<span class="k">fi</span>
</code></pre></div>

<p>上面代码中，不管是脚本正常执行结束，还是用户按 Ctrl + C 终止，都会产生<code>EXIT</code>信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code>命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果<code>trap</code>需要触发多条命令，可以封装一个 Bash 函数。</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span> egress <span class="o">{</span>
  command1
  command2
  command3
<span class="o">}</span>

<span class="nb">trap</span> egress EXIT
</code></pre></div>

<h2 id="_94">参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap">Sending and Trapping Signals</a></li>
</ul>
<h1 id="bash_9">Bash 启动环境</h1>
<h2 id="session">Session</h2>
<p>用户每次使用 Shell，都会开启一个与 Shell 的 Session（对话）。</p>
<p>Session 有两种类型：登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="session_1">登录 Session</h3>
<p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>：所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code>目录里面所有<code>.sh</code>文件</li>
<li><code>~/.bash_profile</code>：用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>：如果<code>~/.bash_profile</code>没找到，则尝试执行这个脚本（C shell 的初始化脚本）。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>：如果<code>~/.bash_profile</code>和<code>~/.bash_login</code>都没找到，则尝试读取这个脚本（Bourne shell 和 Korn shell 的初始化脚本）。</li>
</ul>
<p>Linux 发行版更新的时候，会更新<code>/etc</code>里面的文件，比如<code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在<code>/etc/profile.d</code>目录里面新建<code>.sh</code>脚本。</p>
<p>如果想修改你个人的登录环境，一般是写在<code>~/.bash_profile</code>里面。下面是一个典型的<code>.bash_profile</code>文件。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># .bash_profile</span>
<span class="nv">PATH</span><span class="o">=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$HOME</span>/bin

<span class="nv">SHELL</span><span class="o">=</span>/bin/bash
<span class="nv">MANPATH</span><span class="o">=</span>/usr/man:/usr/X11/man
<span class="nv">EDITOR</span><span class="o">=</span>/usr/bin/vi
<span class="nv">PS1</span><span class="o">=</span><span class="s1">&#39;\h:\w\$ &#39;</span>
<span class="nv">PS2</span><span class="o">=</span><span class="s1">&#39;&gt; &#39;</span>

<span class="k">if</span> <span class="o">[</span> -f ~/.bashrc <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
. ~/.bashrc
<span class="k">fi</span>

<span class="nb">export</span> PATH
<span class="nb">export</span> EDITOR
</code></pre></div>

<p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了<code>~/.bashrc</code>。</p>
<p><code>bash</code>命令的<code>--login</code>参数，会强制执行登录 Session 会执行的脚本。</p>
<div class="highlight"><pre><span></span><code>$ bash --login
</code></pre></div>

<p><code>bash</code>命令的<code>--noprofile</code>参数，会跳过上面这些 Profile 脚本。</p>
<div class="highlight"><pre><span></span><code>$ bash --noprofile
</code></pre></div>

<h3 id="session_2">非登录 Session</h3>
<p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行<code>bash</code>命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>：对全体用户有效。</li>
<li><code>~/.bashrc</code>：仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code>通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以<code>~/.bashrc</code>也是每次执行脚本都会执行的。</p>
<p><code>bash</code>命令的<code>--norc</code>参数，可以禁止在非登录 Session 执行<code>~/.bashrc</code>脚本。</p>
<div class="highlight"><pre><span></span><code>$ bash --norc
</code></pre></div>

<p><code>bash</code>命令的<code>--rcfile</code>参数，指定另一个脚本代替<code>.bashrc</code>。</p>
<div class="highlight"><pre><span></span><code>$ bash --rcfile testrc
</code></pre></div>

<h3 id="bash_logout">.bash_logout</h3>
<p><code>~/.bash_logout</code>脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="_95">启动选项</h2>
<p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>：不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>：输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>：每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li>
</ul>
<div class="highlight"><pre><span></span><code>$ bash -n scriptname
$ bash -v scriptname
$ bash -x scriptname
</code></pre></div>

<h2 id="_96">键盘绑定</h2>
<p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为<code>/etc/inputrc</code>，你可以在主目录创建自己的键盘绑定文件<code>.inputrc</code>文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<div class="highlight"><pre><span></span><code><span class="nv">$include</span> /etc/inputrc
</code></pre></div>

<p><code>.inputrc</code>文件里面的快捷键，可以像这样定义，<code>"\C-t":"pwd\n"</code>表示将<code>Ctrl + t</code>绑定为运行<code>pwd</code>命令。</p>
<h2 id="source">source 命令</h2>
<p><code>source</code>命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">source</span> .bashrc
</code></pre></div>

<p><code>source</code>命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code>命令执行脚本时，不需要<code>export</code>变量。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># test.sh</span>
<span class="nb">echo</span> <span class="nv">$foo</span>
</code></pre></div>

<p>上面脚本输出<code>$foo</code>变量的值。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 当前 Shell 新建一个变量 foo</span>
$ <span class="nv">foo</span><span class="o">=</span><span class="m">1</span>

<span class="c1"># 打印输出 1</span>
$ <span class="nb">source</span> test.sh
<span class="m">1</span>

<span class="c1"># 打印输出空字符串</span>
$ bash test.sh
</code></pre></div>

<p>上面例子中，当前 Shell 的变量<code>foo</code>并没有<code>export</code>，所以直接执行无法读取，但是<code>source</code>执行可以读取。</p>
<p><code>source</code>命令的另一个用途，是在脚本内部加载外部库。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">source</span> ./lib.sh

function_from_lib
</code></pre></div>

<p>上面脚本在内部使用<code>source</code>命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code>有一个简写形式，可以使用一个点（<code>.</code>）来表示。</p>
<div class="highlight"><pre><span></span><code>$ . .bashrc
</code></pre></div>

<h1 id="_97">命令提示符</h1>
<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>
<h2 id="ps1">环境变量 PS1</h2>
<p>命令提示符通常是美元符号<code>$</code>，对于根用户则是井号<code>#</code>。这个符号是环境变量<code>PS1</code>决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="nv">$PS1</span>
</code></pre></div>

<p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后的<code>PS1</code>，可以放在用户的 Bash 配置文件<code>.bashrc</code>里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">source</span> ~/.bashrc
</code></pre></div>

<p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>：响铃，计算机发出一记声音。</li>
<li><code>\d</code>：以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>：本机的主机名。</li>
<li><code>\H</code>：完整的主机名。</li>
<li><code>\j</code>：运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>：当前终端设备名。</li>
<li><code>\n</code>：一个换行符。</li>
<li><code>\r</code>：一个回车符。</li>
<li><code>\s</code>：Shell 的名称。</li>
<li><code>\t</code>：24小时制的<code>hours:minutes:seconds</code>格式表示当前时间。</li>
<li><code>\T</code>：12小时制的当前时间。</li>
<li><code>\@</code>：12小时制的<code>AM/PM</code>格式表示当前时间。</li>
<li><code>\A</code>：24小时制的<code>hours:minutes</code>表示当前时间。</li>
<li><code>\u</code>：当前用户名。</li>
<li><code>\v</code>：Shell 的版本号。</li>
<li><code>\V</code>：Shell 的版本号和发布号。</li>
<li><code>\w</code>：当前的工作路径。</li>
<li><code>\W</code>：当前目录名。</li>
<li><code>\!</code>：当前命令在命令历史中的编号。</li>
<li><code>\#</code>：当前 shell 会话中的命令数。</li>
<li><code>\$</code>：普通用户显示为<code>$</code>字符，根用户显示为<code>#</code>字符。</li>
<li><code>\[</code>：非打印字符序列的开始标志。</li>
<li><code>\]</code>：非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code>这个提示符定义，显示出来就是<code>[user@host ~]$</code>（具体的显示内容取决于你的系统）。</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">echo</span> <span class="nv">$PS1</span>
<span class="o">[</span><span class="se">\u</span>@<span class="se">\h</span> <span class="se">\W</span><span class="o">]</span><span class="se">\$</span>
</code></pre></div>

<p>改写<code>PS1</code>变量，就可以改变这个命令提示符。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">PS1</span><span class="o">=</span><span class="s2">&quot;\A \h \$ &quot;</span>
<span class="m">17</span>:33 host $
</code></pre></div>

<p>注意，<code>$</code>后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="_98">颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>：黑色</li>
<li><code>\033[1;30m</code>：深灰色</li>
<li><code>\033[0;31m</code>：红色</li>
<li><code>\033[1;31m</code>：浅红色</li>
<li><code>\033[0;32m</code>：绿色</li>
<li><code>\033[1;32m</code>：浅绿色</li>
<li><code>\033[0;33m</code>：棕色</li>
<li><code>\033[1;33m</code>：黄色</li>
<li><code>\033[0;34m</code>：蓝色</li>
<li><code>\033[1;34m</code>：浅蓝色</li>
<li><code>\033[0;35m</code>：粉红</li>
<li><code>\033[1;35m</code>：浅粉色</li>
<li><code>\033[0;36m</code>：青色</li>
<li><code>\033[1;36m</code>：浅青色</li>
<li><code>\033[0;37m</code>：浅灰色</li>
<li><code>\033[1;37m</code>：白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将<code>PS1</code>设成下面的代码。</p>
<div class="highlight"><pre><span></span><code><span class="nv">PS1</span><span class="o">=</span><span class="s1">&#39;\[\033[0;31m\]&lt;\u@\h \W&gt;\$&#39;</span>
</code></pre></div>

<p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码<code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div class="highlight"><pre><span></span><code><span class="nv">PS1</span><span class="o">=</span><span class="s1">&#39;\[\033[0;31m\]&lt;\u@\h \W&gt;\$\[\033[00m\]&#39;</span>
</code></pre></div>

<p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>：蓝色</li>
<li><code>\033[1;44m</code>：黑色</li>
<li><code>\033[0;41m</code>：红色</li>
<li><code>\033[1;45m</code>：粉红</li>
<li><code>\033[0;42m</code>：绿色</li>
<li><code>\033[1;46m</code>：青色</li>
<li><code>\033[0;43m</code>：棕色</li>
<li><code>\033[1;47m</code>：浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div class="highlight"><pre><span></span><code><span class="nv">PS1</span><span class="o">=</span><span class="s1">&#39;\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\] &#39;</span>
</code></pre></div>

<h2 id="ps2ps3ps4">环境变量 PS2，PS3，PS4</h2>
<p>除了<code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量<code>PS2</code>是命令行折行输入时系统的提示符，默认为<code>&gt;</code>。</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;hello</span>
<span class="s2">&gt; world&quot;</span>
</code></pre></div>

<p>上面命令中，输入<code>hello</code>以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是<code>PS2</code>定义的<code>&gt;</code>。</p>
<p>环境变量<code>PS3</code>是使用<code>select</code>命令时，系统输入菜单的提示符。</p>
<p>环境变量<code>PS4</code>默认为<code>+</code>。它是使用 Bash 的<code>-x</code>参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本<code>test.sh</code>。</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">&quot;hello world&quot;</span>
</code></pre></div>

<p>使用<code>-x</code>参数执行这个脚本。</p>
<div class="highlight"><pre><span></span><code>$ bash -x test.sh
+ <span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span>
hello world
</code></pre></div>

<p>上面例子中，输出的第一行前面有一个<code>+</code>，这就是变量<code>PS4</code>定义的。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../pragmatic_programmer/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 程序员修炼之道" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              程序员修炼之道
            </div>
          </div>
        </a>
      
      
        
        <a href="../../translate/linux_sysadmin/" class="md-footer__link md-footer__link--next" aria-label="下一页: linux系统管理" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              linux系统管理
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2016 - 2021 iswade
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.5a2dcb6a.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>