
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://iswade.github.io/translate/go_interface/">
      
      <link rel="icon" href="../../themes/me.svg">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>如何使用Go接口 - iswade's blog</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.975780f9.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.2505c338.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../themes/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#go" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="iswade&#39;s blog" class="md-header__button md-logo" aria-label="iswade's blog" data-md-component="logo">
      
  <img src="../../themes/me.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            iswade's blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              如何使用Go接口
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
            </label>
          
        
          
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="iswade&#39;s blog" class="md-nav__button md-logo" aria-label="iswade's blog" data-md-component="logo">
      
  <img src="../../themes/me.svg" alt="logo">

    </a>
    iswade's blog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        主页
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          数据库
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数据库" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          数据库
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notes/adb_nodes/00_index/" class="md-nav__link">
        高级数据库笔记
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/buffer/buffer_details/" class="md-nav__link">
        PostgreSQL缓存
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../crdb/crdb_paper_cn/" class="md-nav__link">
        CockroachDB翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../crdb/crdb_paper/" class="md-nav__link">
        CockroachDB论文
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../taurus_paper_cn/" class="md-nav__link">
        TaurusDB翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../taurus_paper/" class="md-nav__link">
        TaurusDB论文
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/pebble/" class="md-nav__link">
        PebbleKV存储引擎
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../faunadb_transaction/" class="md-nav__link">
        FaunaDB分布式事务
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Aurora_design_cloud_native_database/" class="md-nav__link">
        Aurora数据库
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../btree_vs_lsmtree/" class="md-nav__link">
        BTREEvsLSMTree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notes/db_nodes/00_database_systems_2018/" class="md-nav__link">
        数据库笔记
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../F1_query/" class="md-nav__link">
        F1 Query
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          分布式
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="分布式" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          分布式
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../distsys/" class="md-nav__link">
        分布式系统大纲
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/partition/" class="md-nav__link">
        数据分区
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../strong_consistency_models/" class="md-nav__link">
        强一致性模型
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../zookeeper/" class="md-nav__link">
        Zookeeper翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../paxos_made_live/" class="md-nav__link">
        PaxosMadeLive翻译
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          编程语言
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="编程语言" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          编程语言
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../articles/go_concurrency/" class="md-nav__link">
        Go并发编程
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          如何使用Go接口
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        如何使用Go接口
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    接口介绍
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#interface" class="md-nav__link">
    interface{} 类型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    指针和接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    真实的示例
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    实际的接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    结束语
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          软件工程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="软件工程" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          软件工程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notes/pragmatic_programmer/" class="md-nav__link">
        程序员修炼之道
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notes/bash_turorial/" class="md-nav__link">
        bash教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../linux_sysadmin/" class="md-nav__link">
        linux系统管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../notes/git/" class="md-nav__link">
        git入门教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    接口介绍
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#interface" class="md-nav__link">
    interface{} 类型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    指针和接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    真实的示例
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    实际的接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    结束语
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="go">如何使用 Go 接口？</h1>
<p>在开始 Go 语言编程之前，我所有的工作基本都是用 Python 完成的。作为一个 Python 程序员，我发现在 Go 语言中如何使用接口是非常困难的。基础部分非常简单，我也知道如何使用标准库中的接口，但是在设计自己的接口之前，我还是花费了一些时间来做练习的。在这篇文章中，我会讨论一下 Go 的类型系统，以解释如何有效地使用接口。</p>
<h2 id="_1">接口介绍</h2>
<p>什么是接口呢？接口是由两部分组成：一个方法集合，以及一个类型。首先我们将关注点集中到方法集合上。</p>
<p>通常情况下，我们都会介绍一些例子。让我们写一些程序，这些程序定义了 <code>Animial</code> 数据类型，这也是现实生活中经常发生的事情，<code>Animal</code> 类型是一个接口，定义 <code>Animal</code> 类型为任何可以说话的东西。这是 Go 语言类型系统的核心：我们不是以可以容纳的数据类型的形式定义我们的抽象，而是根据我们的类型可以执行的动作类设计我们的抽象。</p>
<p>我们用定义我们的 <code>Animal</code> 接口作为开始：</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span> <span class="nx">Animal</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div>

<p>非常简单：我们定义 <code>Animal</code> 可以是任何有一个名为 <code>Speak</code> 方法的类型。<code>Speak</code> 方法没有入参，返回值是一个字符串。任何定义了这个方法的类型都满足 <code>Animal</code> 接口。在 Go 语言中没有 <code>implements</code> 关键字：一个类型是否满足一个接口是自动确定的。让我们创建一些类型，这些类型都满足这个接口：</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Woof~~&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Cat</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Meow~~&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Llama</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">Llama</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;~~~~~~&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">JavaProgrammer</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">JavaProgrammer</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Design patterns~~&quot;</span>
<span class="p">}</span>
</code></pre></div>

<p>现在我们定义了5个不同的动物类型：一条狗、一个猫、一个骆驼以及一个 Java 程序员。在 <code>main()</code> 函数中，可以创建动物类型的切片，然后将每个类型中的一个放到切片中，我们来看看每个动物会说什么。让我们现在开始：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">animals</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">Animal</span><span class="p">{</span><span class="nx">Dow</span><span class="p">{},</span> <span class="nx">Cat</span><span class="p">{},</span> <span class="nx">Llama</span><span class="p">{},</span> <span class="nx">JavaProgrammer</span><span class="p">{}}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">animal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">animals</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">animal</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>可以在这个链接中查看示例：<a href="https://play.golang.org/p/fZIzZHEYsj8">https://play.golang.org/p/fZIzZHEYsj8</a></p>
<p>非常好，你现在知道如何使用接口了，我不再需要讨论了，确实如此？实际并非如此。让我们看一些对于新手 Go 程序员并不是那么明显的内容。</p>
<h2 id="interface"><code>interface{}</code> 类型</h2>
<p><code>interface{}</code> 类型（空接口）是混乱的根源。<code>interface{}</code> 类型是一个没有任何方法的接口。由于没有 <code>implements</code> 关键字，所有类型至少实现了零个方法，并且自动满足一个接口，所有类型都满足空接口。这意味着，如果你写了一个以 <code>interface{}</code> 做为入参类型，你可以给该函数任何值。所以，这个函数：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nx">DoSomething</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>可以接受任何参数。</p>
<p>这里会令人困惑：在 <code>DoSomething</code> 函数的内部，v 的类型是什么？新手认为“v 是任何类型”，但这是错误的。v 不是任何类型：它是 <code>interface{}</code> 类型。什么？当给 <code>DoSomething</code> 函数传入一个值，如有必要，Go 运行时会进行类型转换，将一个值转换为 <code>interface{}</code> 值。所有的值在运行时被转换为一个类型，v 的一个静态类型是 <code>interface{}</code>。</p>
<p>这会让你有点怀疑：如果发生了转换，实际被传递给这个函数的是什么（或者说，存储在 <code>[]Animal</code> 切片中的实际内容是什么）？一个接口值由两个字段构成：一个字段用来指向值的底层类型的方法表，另一个字段指向保存值的实际内容。我不想无休止地地谈论这件事了。如果你理解一个接口的值是两个字的大小，并且它包含一个指向底层数据的指针，这就足以避免常见的陷阱。如果你对接口的实现感兴趣，<a href="https://research.swtch.com/interfaces">Russ Cox 的接口描述</a>很有帮助。</p>
<p>前面的例子中，当构造一个 <code>Animal</code> 值得切片的时候，不需要构造 <code>Animal(Dog{})</code> ，将一个 <code>Dog</code> 类型的值存到 <code>Animal</code> 值的切片中，转换对我们来说是自动处理的。在 <code>animals</code> 切片的内部，每个元素都是 <code>Animal</code> 类型，但是不同的值有不同的底层类型。</p>
<p>所以…… 为什么这很重要呢？理解接口在内存中如何表示会使得一些令人困惑的事情变得非常明显。例如这个问题“我可以将 <code>[]T</code> 转换为 <code>[]interface</code> 吗？”，就很容易回答了，如果你已经理解了接口如何在内存中表示。 有一个例子可以代表对常见的误解 <code>interface{}</code> 类型：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">PrintAll</span><span class="p">(</span><span class="nx">vals</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">names</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;standley&quot;</span><span class="p">,</span> <span class="s">&quot;david&quot;</span><span class="p">,</span> <span class="s">&quot;oscar&quot;</span><span class="p">}</span>
    <span class="nx">PrintAll</span><span class="p">(</span><span class="nx">names</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>在这里运行：<a href="https://play.golang.org/p/YRCLmkxLZ-v">https://play.golang.org/p/YRCLmkxLZ-v</a></p>
<p>通过运行，你可以看到会有如下的报错信息：<code>cannot use names (type []string) as type []interface {} in argument to PrintAll</code>。如果你想实际将代码运行其阿里，可以转换 <code>[]string</code> 为 <code>[]interface{}</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">PrintAll</span><span class="p">(</span><span class="nx">vals</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">names</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;stanley&quot;</span><span class="p">,</span> <span class="s">&quot;david&quot;</span><span class="p">,</span> <span class="s">&quot;oscar&quot;</span><span class="p">}</span>
    <span class="nx">vals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nb">len</span><span class="p">(</span><span class="nx">names</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">names</span> <span class="p">{</span>
        <span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nx">PrintAll</span><span class="p">(</span><span class="nx">vals</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>在这里运行：<a href="https://play.golang.org/p/GwJQV4aVjJ1">https://play.golang.org/p/GwJQV4aVjJ1</a></p>
<p>这些代码很丑，但这是实际情况。不是一切事情都是完美的。（实际情况是，这不经常出现，因为 <code>[]interface{}</code> 比你最初期望的用处少）</p>
<h2 id="_2">指针和接口</h2>
<p>接口的另一个微妙之处在于接口定义并不规定实现者是否应该使用指针接受者或者值接受者来实现接口。当你给一个接口值的时候，这里并没有保证底层类型是或者不是一个指针。在前面的例子中，我们在值接受者上定义了所有的方法。我们稍作更改并且将猫的 <code>Speak()</code> 方法变为指针接受者：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Meow~&quot;</span>
<span class="p">}</span>
</code></pre></div>

<p>如果改变了一个签名，然后尝试运行同样的程序(<a href="https://play.golang.org/p/TvR758rfre">https://play.golang.org/p/TvR758rfre</a>)，你会看到下面的报错信息：</p>
<div class="highlight"><pre><span></span><code>prog.go:40: cannot use Cat literal (type Cat) as type Animal in array element:
    Cat does not implement Animal (Speak method requires pointer receiver)
</code></pre></div>

<p>说实话，这条报错信息乍一看有点令人困惑。不是说接口 <code>Animal</code> 满足你定义的指针接受者的方法，而是你尝试将 <code>Cat</code> 结构转换为一个 <code>Animal</code> 接口值，但是只有 <code>*Cat</code> 满足这个接口。如果你想修改这个 bug，可以传递一个 <code>*Cat</code> 指针给 <code>Animal</code> 切片，而不是 <code>Cat</code> 值，通过使用 <code>new(Cat)</code>（也可以使用 <code>&amp;Cat</code>，我更喜欢用 <code>new(Cat)</code>）：</p>
<div class="highlight"><pre><span></span><code><span class="nx">animals</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">Animal</span><span class="p">{</span><span class="nx">Dog</span><span class="p">{},</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Cat</span><span class="p">),</span> <span class="nx">Llama</span><span class="p">{},</span> <span class="nx">JavaProgrammer</span><span class="p">{}}</span>
</code></pre></div>

<p>现在我们的程序又正常工作了：<a href="https://play.golang.org/p/x5VwyExxBM">https://play.golang.org/p/x5VwyExxBM</a></p>
<p>我们朝相反的方向看一下：使用 <code>*Dog</code> 指针替代 <code>Dog</code> 值，但是我们不变更 <code>Dog</code> 类型的 <code>Speak</code> 方法：</p>
<div class="highlight"><pre><span></span><code><span class="nx">animals</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">Animal</span><span class="p">{</span><span class="nb">new</span><span class="p">(</span><span class="nx">Dog</span><span class="p">),</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Cat</span><span class="p">),</span> <span class="nx">Llama</span><span class="p">{},</span> <span class="nx">JavaProgrammer</span><span class="p">{}}</span>
</code></pre></div>

<p>这也是正常工作的（<a href="https://play.golang.org/p/UZ618qbPkj">https://play.golang.org/p/UZ618qbPkj</a>)，但是需要注意一些细微的差异：我们没有必要变更 Speak 方法的接受者的类型。能正常工作的原因是指针类型可以访问关联值类型的方法，但反之却不行。一个 <code>*Dog</code> 值可以使用 Speak 方法，但正如我们前面看到的，不能使用定义在 <code>*Cat</code> 上的 <code>Speak</code> 方法。</p>
<p>这听起来有点神秘，但是当你记下如下内容时就有意义了：Go 中一切都是按照值来传递的。每次调用方法的时候，都会拷贝传递的数据。在有一个值接受者的场景下，当调用方法的时候值被拷贝。当你理解如下方法签名的时候，就会更加明白了：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span><span class="nx">MyMethod</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>是一个类型 <code>func(T, string)</code> 的函数；方法接受者被传递给函数就像另一个参数一样。</p>
<p>在一个值类型上定义的方法，对于接受者的任何变更都是在方法的内部（例如：<code>func (d Dob) Speak() { … }</code>），所以不会被任何调用者看到，因为调用者在处理完全分离的 <code>Dog</code> 值。由于一切都是按值传递，所以一个 <code>*Cat</code> 方法不能被 <code>Cat</code> 值类型使用；任何 <code>Cat</code> 值可以有任意个数的 <code>*Cat</code> 指针指向它。如果我们尝试通过 <code>Cat</code> 值来调用 <code>*Cat</code> 方法，我们没有一个 <code>*Cat</code> 指针开始。反过来，如果我们有一个 <code>Dog</code> 类型的方法，我们有一个 <code>*Dog</code> 指针，当调用这个方法的时候，我们会很准确地知道哪个 <code>Dog</code> 值来使用。因为 <code>*Dog</code> 指针只会指向一个 <code>Dog</code> 值。如有必要，Go运行时解引用指针为其关联的 <code>Dog</code> 值。这就意味着，给定一个 <code>*Dog</code> 值 <code>d</code> 和一个 <code>Dog</code> 类型上的 <code>Speak</code> 方法，我们可以通过 <code>d.Speak()</code> 这种方式调用方法，不需要跟其它语言一样使用 <code>d-&gt;Speak()</code> 进行调用。</p>
<h2 id="_3">真实的示例</h2>
<p>从 Twitter API 获取正确的时间戳。Twitter API 使用一个如下格式的字符串来表示时间戳：</p>
<div class="highlight"><pre><span></span><code>&quot;Thu May 31 00:00:01 +0000 2012&quot;
</code></pre></div>

<p>当然，在 JSON 文档中，时间戳可以用其它的一些方法表示，因为时间戳不是 JSON 规范的一部分。为了保持简洁，我们不会放置一条 tweet 的所有 JSON 表示，让我们仅看一下 <code>create_at</code> 字段如何通过 <code>encoding/json</code> 处理：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;encoding/json&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="c1">// start with a string representation of our JSON data</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="p">=</span> <span class="s">`</span>
<span class="s">{</span>
<span class="s">    &quot;created_at&quot;: &quot;Thu May 31 00:00:01 +0000 2012&quot;</span>
<span class="s">}</span>
<span class="s">`</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// our taarget will be of type map[string]interface{}, which is a </span>
    <span class="c1">// pretty generic type that will give us a hashtable whose keys</span>
    <span class="c1">// are strings, and whose values are of type interface{}</span>
    <span class="kd">var</span> <span class="nx">val</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">input</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">val</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">val</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>在这里运行：<a href="https://play.golang.org/p/VJAyqO3hTF">https://play.golang.org/p/VJAyqO3hTF</a></p>
<p>运行这个应用程序，我们会看到如下的输出：</p>
<div class="highlight"><pre><span></span><code>map[created_at:Thu May 31 00:00:01 +0000 2012]
created_at string
</code></pre></div>

<p>可以看到，我们正确接受到了 <code>key</code>，但是获得了并不是很有用的字符串格式。如果我们想比较哪个时间戳更早，或者我们想知道给定一个值之后，跟当前时间比较过去了多久，使用纯字符串不会有任何帮助。</p>
<p>我们将尝试将字符串转换为一个时间类型：<code>time.Time</code> 值，这是标准库中表示时间的方式 ，我们会获得 <code>error</code> 类型，做如下的变更：</p>
<div class="highlight"><pre><span></span><code>   <span class="kd">var</span> <span class="nx">val</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">input</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">val</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div>

<p>运行后，我们会获得如下的错误：</p>
<div class="highlight"><pre><span></span><code>parsing time &quot;&quot;Thu May 31 00:00:01 +0000 2012&quot;&quot; as &quot;&quot;2006-01-02T15:04:05Z07:00&quot;&quot;:
    cannot parse &quot;Thu May 31 00:00:01 +0000 2012&quot;&quot; as &quot;2006&quot;
</code></pre></div>

<p>上面有点令人困惑的错误信息是由于 Go 中处理 <code>time.Time</code> 类型时间转换的的方式。简而言之，我们给出的字符串的表示方式与标准时间格式不一致（因为 Twitter 的 API 最初是由 Ruby 语言编写的，Ruby 中默认的格式与 Go 中默认的格式不一致）。为了正确解码，我们需要定义自己的类型。<code>encoding/json</code> 包会查看传递给 <code>json.Unmarshal</code> 的值是否满足 <code>json.Unmarshaler</code> 接口，看起来像这样：</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span> <span class="nx">Unmarshaler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">UnmarshalJSON</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>

<p>引用自文档：<a href="https://golang.org/pkg/encoding/json/#Unmarshaler">https://golang.org/pkg/encoding/json/#Unmarshaler</a></p>
<p>所以我们需要的是一个带有 <code>UnmarshalJSON([]byte)  error</code> 方法的 <code>time.Time</code> 值：</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span> <span class="nx">Timestamp</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timestamp</span><span class="p">)</span> <span class="nx">UnmarshalJSON</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// ....</span>
<span class="p">}</span>
</code></pre></div>

<p>通过实现这个方法，满足了 <code>json.Unmarshaler</code> 接口，当看到 <code>Timestamp</code> 值时，<code>json.Unmarshal</code> 会调用我们实现的代码。这种情况下，使用一个指针方法，因为我们想要调用者看到变更的内容。为了设置一个指针指向的值，我们可以通过手动使用 * 操作符进行解引用。在 <code>UnmarshalJSON</code> 方法内部，<code>t</code> 表示一个指向 <code>Timestamp</code> 类型的指。通过使用 <code>*t</code>，我们可以解引用指针 <code>t</code>，可以访问 <code>t</code> 指向的值。记住：在 Go 中一切都是通过值传递。在 <code>UnmarshalJSON</code> 方法内部，指针 t 跟调用上下文中的指针是不一样的：是一个拷贝。如果我们给 t 赋值为另一个值，你仅仅是给一个函数内部的变量赋值，变更不会被调用者看到。但是，在方法内部的指针跟调用上下文中的指针指向同一块数据，通过解引用指针，我们可以将变更传递给调用者。</p>
<p>我们可以使用 <code>time.Parse</code> 方法，带有签名信息 <code>func(layout, value string) (Time, error)</code>。有两个字符串入参：第一个字符串是一个布局字符串，描述了我们如何格式化时间戳，第二个是希望解析的值。返回一个 <code>time.Time</code> 值，以及一个错误信息（在出现解析失败的时候使用）。你可以在<a href="https://golang.org/pkg/time/">时间包文档</a>中阅读关于布局字符串语义的更多信息，但在本例中，我们不需要手动给出布局字符串，因为这些布局信息已经在标准包中存在了，例如值 <code>time.RubyDate</code>。所以实际上，我们可以解析字符串 "Thu May 31 00:00:01 +0000 2012" 为一个 time.Time 值，通过调用 <code>time.Parse(time.RubyDate, "Thu May 31 00:00:01 +0000 2012")</code>。我们接受到的值是一个 <code>time.Time</code> 类型的。我们可以转换 <code>time.Time</code> 值为 <code>Timestamp</code> 值通过调用 <code>Timestamp(v)</code>，这里 <code>v</code> 是我们的 <code>time.Time</code> 值。最终，我们可以使用的  <code>UnmarshalJSON</code> 函数如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timestamp</span><span class="p">)</span> <span class="nx">UnmarshalJSON</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RubyDate</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">Timestamp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>

<p>在这个例子中，我们将入参的 <code>byte</code> 切片处理成子切片，因为输入的子切片是 JSON 元素的原始数据，包含的引号，在传入 <code>time.Parse</code> 之前，我们将引号删除掉。</p>
<p>完整的时间戳类型的例子可以在这里查看（也可以运行）：<a href="http://play.golang.org/p/QpiFsJi-nZ">http://play.golang.org/p/QpiFsJi-nZ</a></p>
<h2 id="_4">实际的接口</h2>
<p>从一个 http 请求中获取一个对象。让我们来看看如何设计一个接口来解决一个常见的 web 开发问题：我们希望将 HTTP 请求的正文解析为一些对象数据。首先，这不是一个非常明确的定义接口。我们或许可以这样说：我们要这样从 HTTP 请求获取资源：</p>
<div class="highlight"><pre><span></span><code><span class="nx">GetEntity</span><span class="p">(</span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div>

<p>因为一个 <code>interface{}</code> 可以用来处理任何底层类型，所以我们可以仅仅将我们的请求解析，然后返回我们需要的内容。这被认为是一个非常不好的策略，原因是我们在 <code>GetEntity</code> 函数中粘贴了太多的逻辑，这个函数对于每个新的类型都需要做修改，并且我们需要使用类型断言来处理返回的 interface{} 值。在实践中，一个返回 <code>interface{}</code> 值的函数会令人非常讨厌，作为一个经验法则，您可以记住，接受 <code>interface{}</code> 值作为参数通常比返回接口值更好。（Postel 定律，也适用于接口）</p>
<p>我们或许会尝试使用如下类型固定的函数：</p>
<div class="highlight"><pre><span></span><code><span class="nx">GetUser</span><span class="p">(</span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div>

<p>这也被证明是非常不灵活的，因为每个类型我们都需要不同的函数，但是没有合理的方法来将他们通用化。相反，我们真真需要的是像下面的这样：</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span> <span class="nx">Entity</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">UnmarshalHTTP</span><span class="p">(</span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">GetEntity</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">Entity</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">UnmarshalHTTP</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>这里的 <code>GetEntity</code> 函数采用了一个具有 <code>UnmarshalHTTP</code> 方法的接口值。为了利用这一点，我们将在对象上定义一些方法，允许用户描述如何从 HTTP 请求中获得自己的信息：</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">User</span><span class="p">)</span> <span class="nx">UnmarshalHTTP</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>在我们的应用代码中，你会定义一个 <code>User</code> 类型的变量，然后将指针传递给 <code>GetEntity</code> 函数：</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">u</span> <span class="nx">User</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">GetEntity</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">u</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>这跟你如何解析 JSON 数据非常相似。这种类型使用的方式可以正常安全地工作，因为语句 <code>var u User</code> 会自动将 <code>User</code> 结构体归零。Go 不像其它语言需要什么的初始化分开，不初始化的申明变量会导致访问到无效数据，当申明变量的时候，运行时会自动将对应的内存内容清零，即使我们的 <code>UnmarshalHTTP</code> 方法处理一些字段失败，这些字段也会包含零值而不是垃圾数据。</p>
<p>如果你是一名 Python 程序员，这对你来说肯定很奇怪，因为 Python 中通常不会这么做。这种形式变得很方便的原因是我们可以定义任意数量的数据类型，每个类型都负责从 http 请求中自行解析。现在由实体定义决定如何表示它们，然后我们可以围绕 Entity 类型来创建类似于通用 HTTP 的处理程序。</p>
<h2 id="_5">结束语</h2>
<p>我希望，在阅读这篇文章后，你会在 Go 中使用接口感觉更加顺畅。请记住如下几点：</p>
<ul>
<li>通过考虑数据类型之间通用的功能来创建抽象，而不是数据类型之间的通用字段</li>
<li><code>interface{}</code> 接口不是任何类型：它是一个 <code>interface{}</code> 类型</li>
<li>接口是两个字的宽度：示意图如(type, value)</li>
<li>接受 <code>interface{}</code> 值作为入参比返回一个 <code>interface{}</code> 值更好</li>
<li>一个指针类型可以调用关联值类型的方法，但是反之却不行</li>
<li>一切都是通过值传递，及时是一个方法的接受者</li>
<li>一个借口类型不是严格的指针或者非指针，仅仅是一个接口</li>
<li>如果你需要完全重写一个方法的内部的值，使用 <code>*</code> 操作符来手动解应用一个指针</li>
</ul>
<p>我认为已经总结了我个人觉得所有关于接口的令人困惑的场景。编码快乐 :)</p>
<p>原文链接：<a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go</a></p>
<p>作者：Jordan Orelli</p>
<p>翻译：王世德</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../../articles/go_concurrency/" class="md-footer__link md-footer__link--prev" aria-label="上一页: Go并发编程" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              Go并发编程
            </div>
          </div>
        </a>
      
      
        
        <a href="../../notes/pragmatic_programmer/" class="md-footer__link md-footer__link--next" aria-label="下一页: 程序员修炼之道" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              程序员修炼之道
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2016 - 2022 iswade
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.5a2dcb6a.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>